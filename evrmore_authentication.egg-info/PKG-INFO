Metadata-Version: 2.1
Name: evrmore-authentication
Version: 0.1.0
Summary: Authentication system using Evrmore blockchain signatures
Home-page: https://github.com/manticoretechnologies/evrmore-authentication
Author: Manticore Technologies
Author-email: dev@manticore.technology
License: UNKNOWN
Project-URL: Documentation, https://manticoretechnologies.github.io/evrmore-authentication/
Project-URL: Bug Tracker, https://github.com/manticoretechnologies/evrmore-authentication/issues
Platform: UNKNOWN
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: Topic :: Security :: Cryptography
Requires-Python: >=3.6
Description-Content-Type: text/markdown

# Evrmore Authentication

[![PyPI version](https://badge.fury.io/py/evrmore-authentication.svg)](https://badge.fury.io/py/evrmore-authentication)
[![Documentation Status](https://readthedocs.io/en/latest/?badge=latest)](https://evrmore-authentication.readthedocs.io/en/latest/?badge=latest)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

A robust, secure authentication system that leverages Evrmore blockchain signatures for user authentication and session management.

![Evrmore Authentication Demo](docs/screenshots/auth-demo.png)

## Overview

Evrmore Authentication provides a complete solution for implementing blockchain-based authentication in your applications. It leverages the cryptographic signing capabilities of Evrmore wallets to provide secure, passwordless authentication.

### Key Features

- **Blockchain-Based Authentication**: Uses Evrmore wallet signatures for secure, passwordless authentication
- **Challenge-Response Protocol**: Implements a secure challenge-response authentication flow
- **Cross-Database Support**: Works with both PostgreSQL (production) and SQLite (development/testing)
- **JWT Integration**: Issues and validates JWT tokens for session management
- **Complete Web Demo**: Includes a fully functional web application example
- **Standalone REST API**: Run as a dedicated authentication service
- **Comprehensive Documentation**: 100% documentation coverage

## Quick Start

### One-Command Setup

We provide a convenient startup script that handles everything for you:

```bash
# Clone the repository
git clone https://github.com/manticoretechnologies/evrmore-authentication.git
cd evrmore-authentication

# Make the startup script executable
chmod +x start_auth_server.sh

# Start the server
./start_auth_server.sh
```

This script will:
1. Check for dependencies
2. Install required packages
3. Create a `.env` file with secure defaults if it doesn't exist
4. Initialize the SQLite database
5. Check for Evrmore node availability
6. Find an available port
7. Start the API server

### Run the Demo

Once the server is running, you can run the demo script to see the complete authentication flow:

```bash
# Make the demo script executable
chmod +x demo.sh

# Run the demo
./demo.sh
```

This demo will:
1. Generate a new Evrmore address
2. Generate a challenge for this address
3. Sign the challenge with your Evrmore wallet
4. Authenticate using the signature
5. Validate the JWT token
6. Fetch user information
7. Logout (invalidate the token)
8. Try to access a protected resource with the invalidated token

## Installation

### Standard Installation

```bash
pip3 install evrmore-authentication
```

### Development Installation

```bash
git clone https://github.com/manticoretechnologies/evrmore-authentication.git
cd evrmore-authentication
pip3 install -e .
```

## Configuration

Create a `.env` file in your project root:

```bash
# Database configuration
DB_TYPE=sqlite  # or postgresql
SQLITE_DB_PATH=evrmore_auth.db  # for SQLite

# For PostgreSQL
# DB_HOST=localhost
# DB_PORT=5432
# DB_NAME=evrmore_auth
# DB_USER=postgres
# DB_PASSWORD=your_password

# JWT configuration
JWT_SECRET=your-secret-key
JWT_ALGORITHM=HS256
JWT_ACCESS_TOKEN_EXPIRE_MINUTES=30

# Challenge configuration
CHALLENGE_EXPIRE_MINUTES=10

# Evrmore node configuration
EVRMORE_RPC_HOST=localhost
EVRMORE_RPC_PORT=8819
EVRMORE_RPC_USER=your_username
EVRMORE_RPC_PASSWORD=your_password

# For REST API
CORS_ORIGINS=http://localhost:3000,https://yourapp.com
```

## Usage

### Python API

```python
from evrmore_authentication import EvrmoreAuth

# Initialize the authentication system
auth = EvrmoreAuth()

# Generate a challenge for a user to sign
challenge = auth.generate_challenge("EVRxxxYourEvrmoreAddressxxx")

# User signs the challenge with their wallet and sends back the signature
signature = "user_provided_signature"

# Authenticate the user using their signature
user_session = auth.authenticate(
    evrmore_address="EVRxxxYourEvrmoreAddressxxx",
    challenge=challenge, 
    signature=signature
)

# Use the token for authentication in subsequent requests
token = user_session.token

# Validate a token
token_data = auth.validate_token(token)

# Get user from token
user = auth.get_user_by_token(token)

# Logout (invalidate token)
auth.invalidate_token(token)
```

### REST API Server

#### Starting the API Server

You can run Evrmore Authentication as a standalone REST API server:

```bash
# Start the API server
evrmore-auth-api

# Start with specific host and port
evrmore-auth-api --host 127.0.0.1 --port 9000

# Enable development mode with auto-reload
evrmore-auth-api --reload

# Specify log level
evrmore-auth-api --log-level debug

# Skip database initialization
evrmore-auth-api --no-init-db
```

#### API Endpoints

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | / | Health check, returns server status |
| POST | /challenge | Generate a challenge for an address |
| POST | /authenticate | Verify a signature and issue a token |
| GET | /validate | Validate a JWT token |
| POST | /logout | Invalidate a token (logout) |
| GET | /me | Get authenticated user info |

#### REST API Client Example

Using `curl`:

```bash
# 1. Generate a challenge
CHALLENGE_RESPONSE=$(curl -s -X POST \
  -H "Content-Type: application/json" \
  -d '{"evrmore_address": "EVRxxxYourEvrmoreAddressxxx"}' \
  http://localhost:8000/challenge)

CHALLENGE=$(echo $CHALLENGE_RESPONSE | jq -r '.challenge')

# 2. Sign the challenge with your wallet
# (This step is done in your wallet)
SIGNATURE="your_wallet_signature"

# 3. Authenticate
AUTH_RESPONSE=$(curl -s -X POST \
  -H "Content-Type: application/json" \
  -d "{\"evrmore_address\": \"EVRxxxYourEvrmoreAddressxxx\", \"challenge\": \"$CHALLENGE\", \"signature\": \"$SIGNATURE\"}" \
  http://localhost:8000/authenticate)

TOKEN=$(echo $AUTH_RESPONSE | jq -r '.token')

# 4. Use the token to access protected resources
curl -s -H "Authorization: Bearer $TOKEN" http://localhost:8000/me

# 5. Logout
curl -s -X POST \
  -H "Content-Type: application/json" \
  -d "{\"token\": \"$TOKEN\"}" \
  http://localhost:8000/logout
```

Using JavaScript:

```javascript
// Generate a challenge
async function generateChallenge(evrmoreAddress) {
  const response = await fetch('http://localhost:8000/challenge', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ evrmore_address: evrmoreAddress })
  });
  return response.json();
}

// Authenticate with the signature
async function authenticate(evrmoreAddress, challenge, signature) {
  const response = await fetch('http://localhost:8000/authenticate', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      evrmore_address: evrmoreAddress,
      challenge: challenge,
      signature: signature
    })
  });
  return response.json();
}
```

Using Python:

```python
import requests

# Generate a challenge
def generate_challenge(evrmore_address):
    response = requests.post(
        "http://localhost:8000/challenge",
        json={"evrmore_address": evrmore_address}
    )
    return response.json()

# Authenticate with a signature
def authenticate(evrmore_address, challenge, signature):
    response = requests.post(
        "http://localhost:8000/authenticate",
        json={
            "evrmore_address": evrmore_address,
            "challenge": challenge,
            "signature": signature
        }
    )
    return response.json()
```

### Web Demo Application

The repository includes a complete web authentication demo:

```bash
cd examples/web_auth_demo
./run.sh
```

This will start a Flask web application demonstrating the authentication flow with:
- Challenge generation with timer
- Wallet signing instructions
- Authentication verification
- Protected dashboard

![Auth Flow](docs/screenshots/auth-flow.png)

## Authentication Flow

1. **Challenge Generation**: Server generates a unique challenge for the user's Evrmore address
2. **Client Signing**: User signs the challenge with their Evrmore wallet's private key
3. **Signature Verification**: Server verifies the signature against the user's public address
4. **Session Creation**: Server creates a session and issues a JWT token
5. **Authenticated Access**: Client uses the JWT token for subsequent authenticated requests

## Framework Integration

### FastAPI

```python
from fastapi import FastAPI, Depends, HTTPException
from evrmore_authentication import get_current_user

app = FastAPI()

@app.post("/auth/challenge")
async def generate_challenge(evrmore_address: str):
    # Generate challenge code

@app.post("/auth/login")
async def login(evrmore_address: str, challenge: str, signature: str):
    # Authenticate code

@app.get("/users/me")
async def read_users_me(current_user = Depends(get_current_user)):
    return current_user
```

### Flask

```python
from flask import Flask, request, jsonify
from evrmore_authentication import EvrmoreAuth

app = Flask(__name__)
auth = EvrmoreAuth()

@app.route('/api/challenge', methods=['POST'])
def generate_challenge():
    # Challenge generation code

@app.route('/api/authenticate', methods=['POST'])
def authenticate():
    # Authentication code
```

## Docker Deployment

### Using the Dockerfile

```bash
# Build the Docker image
docker build -t evrmore-auth-api .

# Run the container
docker run -p 8000:8000 -v $(pwd)/.env:/app/.env evrmore-auth-api
```

### Using Docker Compose

```bash
# Copy the example .env file and adjust it
cp .env.example .env

# Start the services
docker-compose up -d

# View logs
docker-compose logs -f

# Stop the services
docker-compose down
```

## Security Considerations

- Challenges expire after a configurable time period
- Each challenge can only be used once
- Private keys are never transmitted or stored
- JWT tokens can be individually invalidated
- All database operations are atomic
- SQLite and PostgreSQL databases are supported with transparent UUID handling

## Troubleshooting

### JWT Validation Issues

If you encounter issues with token validation:

1. Check that the `JWT_SECRET` is consistent between token generation and validation
2. Ensure your system clock is accurate
3. If running in a development environment with time mismatch, you can disable `iat` validation:
   ```python
   jwt.decode(token, secret, algorithms=['HS256'], options={"verify_iat": False})
   ```

### Database Issues

If you have problems with the database:

1. Make sure your database configuration in `.env` is correct
2. For SQLite, ensure the path is writable
3. For PostgreSQL, check connection parameters and SSL settings
4. Use `--no-init-db` if you've already initialized the database

## Documentation

For complete documentation, see:

- [Getting Started Guide](GETTING_STARTED.md)
- [API Reference](docs/api.md)
- [Developer Guide](docs/guide.md)

## License

MIT License

## About Manticore Technologies

[Manticore Technologies](https://manticore.technology) specializes in blockchain integration and decentralized application development.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## Copyright

© 2023 Manticore Technologies - [manticore.technology](https://manticore.technology) 

