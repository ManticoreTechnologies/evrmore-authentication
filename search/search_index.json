{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Evrmore AuthenticationEvrmore Authentication","text":"<p>Secure blockchain-based authentication using Evrmore wallet signatures</p>"},{"location":"#overview","title":"Overview","text":"<p>Evrmore Authentication is a Python package that provides a secure, blockchain-based authentication system for your applications. It leverages Evrmore wallet signatures to verify user identity without storing passwords.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Blockchain-based Authentication: Uses Evrmore wallet signatures for secure user authentication</li> <li>Challenge-Response Protocol: Generates unique challenges for each authentication attempt</li> <li>Multiple Backend Options: Supports PostgreSQL and Redis as backend storage</li> <li>JWT Support: Issues and validates JSON Web Tokens for authenticated sessions</li> <li>FastAPI Integration: Ready-to-use FastAPI endpoints for authentication</li> <li>Comprehensive Security: Protection against common attack vectors</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># Install the package\npip3 install evrmore-authentication\n\n# Run the API server\npython3 -m scripts.run_api_server --host 0.0.0.0 --port 8000\n\n# Run the web demo\npython3 -m scripts.run_web_demo --port 5000 --api-url http://localhost:8000\n</code></pre>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li>User Guide - Comprehensive guide for using the package</li> <li>API Reference - Detailed technical reference</li> <li>Examples - Code examples and tutorials</li> <li>Development - Contributing to the project</li> </ul>"},{"location":"#authentication-flow","title":"Authentication Flow","text":"<ol> <li>Challenge Generation: The server generates a unique challenge for a user's Evrmore address</li> <li>Signature Creation: The user signs the challenge with their Evrmore wallet</li> <li>Verification: The server verifies the signature against the challenge</li> <li>Token Issuance: Upon successful verification, a JWT token is issued</li> <li>Authentication: The token is used for subsequent API requests</li> </ol>"},{"location":"#about-manticore-technologies","title":"About Manticore Technologies","text":"<p>Manticore Technologies specializes in blockchain integration and development solutions. Visit our website to learn more about our services and projects. </p>"},{"location":"api-reference/","title":"API Reference","text":"<p>This document provides a detailed reference for all the classes, methods, and functions available in the Evrmore Authentication package.</p>"},{"location":"api-reference/#table-of-contents","title":"Table of Contents","text":"<ul> <li>EvrmoreAuth Class</li> <li>UserSession Class</li> <li>Database Models</li> <li>Dependency Utilities</li> <li>Exceptions</li> <li>REST API Server</li> </ul>"},{"location":"api-reference/#evrmoreauth-class","title":"EvrmoreAuth Class","text":"<p>The main class that provides authentication functionality.</p>"},{"location":"api-reference/#constructor","title":"Constructor","text":"<pre><code>EvrmoreAuth(db=None, jwt_secret=None, jwt_algorithm=None)\n</code></pre> <p>Parameters: - <code>db</code> (Session, optional): SQLAlchemy session instance. If not provided, a new session is created. - <code>jwt_secret</code> (str, optional): Secret key for JWT token generation. If not provided, it's taken from environment variables. - <code>jwt_algorithm</code> (str, optional): Algorithm to use for JWT tokens. If not provided, it defaults to \"HS256\".</p> <p>Properties: - <code>evrmore_available</code> (bool): Indicates if the Evrmore node is available.</p>"},{"location":"api-reference/#methods","title":"Methods","text":""},{"location":"api-reference/#generate_challenge","title":"generate_challenge","text":"<pre><code>generate_challenge(evrmore_address, expire_minutes=None)\n</code></pre> <p>Generates a unique challenge for a user to sign.</p> <p>Parameters: - <code>evrmore_address</code> (str): The Evrmore wallet address. - <code>expire_minutes</code> (int, optional): Minutes until the challenge expires. Default from environment variable.</p> <p>Returns: - <code>str</code>: Challenge text to be signed by the user's wallet.</p> <p>Raises: - <code>AuthenticationError</code>: If there is an error generating the challenge.</p>"},{"location":"api-reference/#authenticate","title":"authenticate","text":"<pre><code>authenticate(evrmore_address, challenge, signature, ip_address=None, user_agent=None, token_expire_minutes=None)\n</code></pre> <p>Authenticates a user using their signed challenge.</p> <p>Parameters: - <code>evrmore_address</code> (str): The Evrmore wallet address. - <code>challenge</code> (str): The challenge text that was signed. - <code>signature</code> (str): The signature created by signing the challenge. - <code>ip_address</code> (str, optional): User's IP address. - <code>user_agent</code> (str, optional): User's agent string. - <code>token_expire_minutes</code> (int, optional): Minutes until token expires.</p> <p>Returns: - <code>UserSession</code>: Session data including the JWT token.</p> <p>Raises: - <code>UserNotFoundError</code>: If user with the address is not found. - <code>ChallengeExpiredError</code>: If the challenge has expired. - <code>ChallengeAlreadyUsedError</code>: If the challenge has already been used. - <code>InvalidSignatureError</code>: If signature verification fails. - <code>AuthenticationError</code>: For other authentication errors.</p>"},{"location":"api-reference/#validate_token","title":"validate_token","text":"<pre><code>validate_token(token)\n</code></pre> <p>Validates a JWT token and returns the token payload.</p> <p>Parameters: - <code>token</code> (str): JWT token to validate.</p> <p>Returns: - <code>dict</code>: Token payload data.</p> <p>Raises: - <code>InvalidTokenError</code>: If the token is invalid or expired. - <code>SessionExpiredError</code>: If the session has expired.</p>"},{"location":"api-reference/#get_user_by_token","title":"get_user_by_token","text":"<pre><code>get_user_by_token(token)\n</code></pre> <p>Gets a user by their token.</p> <p>Parameters: - <code>token</code> (str): JWT token to look up.</p> <p>Returns: - <code>User</code>: User object.</p> <p>Raises: - <code>InvalidTokenError</code>: If the token is invalid. - <code>UserNotFoundError</code>: If the user is not found.</p>"},{"location":"api-reference/#invalidate_token","title":"invalidate_token","text":"<pre><code>invalidate_token(token)\n</code></pre> <p>Invalidates a specific token (logout).</p> <p>Parameters: - <code>token</code> (str): JWT token to invalidate.</p> <p>Returns: - <code>bool</code>: True if token was invalidated successfully.</p>"},{"location":"api-reference/#invalidate_all_tokens","title":"invalidate_all_tokens","text":"<pre><code>invalidate_all_tokens(user_id)\n</code></pre> <p>Invalidates all tokens for a specific user (logout from all devices).</p> <p>Parameters: - <code>user_id</code> (str): User ID to invalidate tokens for.</p> <p>Returns: - <code>int</code>: Number of tokens invalidated.</p>"},{"location":"api-reference/#usersession-class","title":"UserSession Class","text":"<p>A dataclass that holds user session information.</p> <pre><code>@dataclass\nclass UserSession:\n    user_id: str\n    evrmore_address: str\n    token: str\n    expires_at: datetime.datetime\n</code></pre>"},{"location":"api-reference/#database-models","title":"Database Models","text":""},{"location":"api-reference/#user","title":"User","text":"<p>Represents an authenticated wallet owner.</p> <p>Fields: - <code>id</code> (UUID): Primary key. - <code>evrmore_address</code> (String): Unique Evrmore address. - <code>username</code> (String, optional): User's username. - <code>email</code> (String, optional): User's email. - <code>is_active</code> (Boolean): Whether the user is active. - <code>created_at</code> (DateTime): When the user was created. - <code>last_login</code> (DateTime, optional): When the user last logged in.</p>"},{"location":"api-reference/#challenge","title":"Challenge","text":"<p>Stores authentication challenges.</p> <p>Fields: - <code>id</code> (UUID): Primary key. - <code>user_id</code> (UUID): Foreign key to User. - <code>challenge_text</code> (Text): The challenge text. - <code>created_at</code> (DateTime): When the challenge was created. - <code>expires_at</code> (DateTime): When the challenge expires. - <code>used</code> (Boolean): Whether the challenge has been used.</p>"},{"location":"api-reference/#session","title":"Session","text":"<p>Stores user authentication sessions.</p> <p>Fields: - <code>id</code> (UUID): Primary key. - <code>user_id</code> (UUID): Foreign key to User. - <code>token</code> (String): JWT token. - <code>token_id</code> (String): The JWT token ID. - <code>created_at</code> (DateTime): When the session was created. - <code>expires_at</code> (DateTime): When the session expires. - <code>is_active</code> (Boolean): Whether the session is active. - <code>ip_address</code> (String, optional): User's IP address. - <code>user_agent</code> (String, optional): User's agent string.</p>"},{"location":"api-reference/#dependency-utilities","title":"Dependency Utilities","text":""},{"location":"api-reference/#get_current_user","title":"get_current_user","text":"<pre><code>async def get_current_user(token: str)\n</code></pre> <p>FastAPI dependency for getting the current authenticated user.</p> <p>Parameters: - <code>token</code> (str): JWT token from HTTP Authorization header.</p> <p>Returns: - <code>User</code>: The current authenticated user.</p> <p>Raises: - <code>HTTPException</code>: If authentication fails.</p>"},{"location":"api-reference/#exceptions","title":"Exceptions","text":"<ul> <li><code>AuthenticationError</code>: Base class for all authentication errors.</li> <li><code>UserNotFoundError</code>: Raised when a user with the given address is not found.</li> <li><code>ChallengeExpiredError</code>: Raised when an authentication challenge has expired.</li> <li><code>ChallengeAlreadyUsedError</code>: Raised when a challenge has already been used.</li> <li><code>InvalidSignatureError</code>: Raised when the signature verification fails.</li> <li><code>SessionExpiredError</code>: Raised when a session has expired.</li> <li><code>InvalidTokenError</code>: Raised when a token is invalid or has been invalidated.</li> <li><code>ConfigurationError</code>: Raised when there's a configuration error.</li> </ul>"},{"location":"api-reference/#rest-api-server","title":"REST API Server","text":"<p>Evrmore Authentication includes a standalone REST API server that can be used to provide authentication services via HTTP endpoints.</p>"},{"location":"api-reference/#api-endpoints","title":"API Endpoints","text":"Endpoint Method Description <code>/challenge</code> POST Generate a challenge for a user <code>/authenticate</code> POST Authenticate with a signed challenge <code>/validate</code> GET Validate a JWT token <code>/me</code> GET Get authenticated user information <code>/logout</code> POST Invalidate a JWT token (logout)"},{"location":"api-reference/sqlite/","title":"SQLite Implementation","text":"<p>This document describes how Evrmore Authentication uses SQLite as a backend storage system.</p>"},{"location":"api-reference/sqlite/#overview","title":"Overview","text":"<p>Evrmore Authentication uses SQLite as a lightweight, file-based database that requires no external server. SQLite provides a simple and reliable way to store and retrieve session data, user information, and authentication challenges.</p>"},{"location":"api-reference/sqlite/#database-schema","title":"Database Schema","text":"<p>The SQLite implementation uses a simple relational database schema with the following tables:</p> Table Description <code>users</code> Stores user data <code>challenges</code> Stores authentication challenges <code>sessions</code> Stores user sessions and tokens"},{"location":"api-reference/sqlite/#table-schemas","title":"Table Schemas","text":""},{"location":"api-reference/sqlite/#users-table","title":"Users Table","text":"<pre><code>CREATE TABLE IF NOT EXISTS users (\n    id TEXT PRIMARY KEY,\n    evrmore_address TEXT UNIQUE NOT NULL,\n    username TEXT,\n    email TEXT,\n    is_active INTEGER NOT NULL DEFAULT 1,\n    created_at TEXT NOT NULL,\n    last_login TEXT\n)\n</code></pre>"},{"location":"api-reference/sqlite/#challenges-table","title":"Challenges Table","text":"<pre><code>CREATE TABLE IF NOT EXISTS challenges (\n    id TEXT PRIMARY KEY,\n    user_id TEXT NOT NULL,\n    challenge_text TEXT NOT NULL,\n    expires_at TEXT NOT NULL,\n    used INTEGER NOT NULL DEFAULT 0,\n    created_at TEXT NOT NULL,\n    FOREIGN KEY (user_id) REFERENCES users (id)\n)\n</code></pre>"},{"location":"api-reference/sqlite/#sessions-table","title":"Sessions Table","text":"<pre><code>CREATE TABLE IF NOT EXISTS sessions (\n    id TEXT PRIMARY KEY,\n    user_id TEXT NOT NULL,\n    token TEXT NOT NULL,\n    expires_at TEXT NOT NULL,\n    is_active INTEGER NOT NULL DEFAULT 1,\n    created_at TEXT NOT NULL,\n    ip_address TEXT,\n    user_agent TEXT,\n    FOREIGN KEY (user_id) REFERENCES users (id)\n)\n</code></pre>"},{"location":"api-reference/sqlite/#data-models","title":"Data Models","text":"<p>The SQLite implementation uses dataclass models to represent the database tables:</p>"},{"location":"api-reference/sqlite/#user-model","title":"User Model","text":"<pre><code>@dataclass\nclass User:\n    id: str\n    evrmore_address: str\n    username: Optional[str] = None\n    email: Optional[str] = None\n    is_active: bool = True\n    created_at: datetime.datetime = field(default_factory=datetime.datetime.utcnow)\n    last_login: Optional[datetime.datetime] = None\n</code></pre>"},{"location":"api-reference/sqlite/#challenge-model","title":"Challenge Model","text":"<pre><code>@dataclass\nclass Challenge:\n    id: str\n    user_id: str\n    challenge_text: str\n    expires_at: datetime.datetime\n    used: bool = False\n    created_at: datetime.datetime = field(default_factory=datetime.datetime.utcnow)\n</code></pre>"},{"location":"api-reference/sqlite/#session-model","title":"Session Model","text":"<pre><code>@dataclass\nclass Session:\n    id: str\n    user_id: str\n    token: str\n    expires_at: datetime.datetime\n    is_active: bool = True\n    created_at: datetime.datetime = field(default_factory=datetime.datetime.utcnow)\n    ip_address: Optional[str] = None\n    user_agent: Optional[str] = None\n</code></pre>"},{"location":"api-reference/sqlite/#handling-datetime-objects","title":"Handling Datetime Objects","text":"<p>SQLite doesn't natively support datetime objects, so they are stored as ISO format strings in the database and converted back to datetime objects when retrieving them.</p> <pre><code>def to_dict(self):\n    \"\"\"Convert User to a dictionary.\"\"\"\n    return {\n        \"id\": str(self.id),\n        \"evrmore_address\": self.evrmore_address,\n        \"username\": self.username,\n        \"email\": self.email,\n        \"is_active\": self.is_active,\n        \"created_at\": self.created_at.isoformat() if self.created_at else None,\n        \"last_login\": self.last_login.isoformat() if self.last_login else None\n    }\n</code></pre>"},{"location":"api-reference/sqlite/#database-connections","title":"Database Connections","text":"<p>The SQLite implementation uses a singleton pattern to manage database connections, ensuring that only one connection is active at a time:</p> <pre><code>class SQLiteManager:\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super(SQLiteManager, cls).__new__(cls)\n            cls._instance.initialized = False\n        return cls._instance\n\n    def __init__(self):\n        if not self.initialized:\n            db_path = os.environ.get('SQLITE_DB_PATH', './data/evrmore_auth.db')\n\n            # Create data directory if it doesn't exist\n            db_dir = os.path.dirname(db_path)\n            if db_dir and not os.path.exists(db_dir):\n                os.makedirs(db_dir, exist_ok=True)\n\n            self.conn = sqlite3.connect(db_path, check_same_thread=False)\n            self.conn.row_factory = sqlite3.Row\n            self._create_tables()\n            self.initialized = True\n</code></pre>"},{"location":"api-reference/sqlite/#configuration-options","title":"Configuration Options","text":"<p>SQLite connection settings can be configured using environment variables:</p> <pre><code>SQLITE_DB_PATH=./data/evrmore_auth.db  # Path to the SQLite database file\n</code></pre>"},{"location":"development/","title":"Development Guide","text":"<p>This guide provides information for developers who want to contribute to the Evrmore Authentication project.</p>"},{"location":"development/#setting-up-the-development-environment","title":"Setting Up the Development Environment","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/manticoretechnologies/evrmore-authentication.git\ncd evrmore-authentication\n</code></pre> <ol> <li>Create a virtual environment:</li> </ol> <pre><code>python3 -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n</code></pre> <ol> <li>Install the package in development mode:</li> </ol> <pre><code>pip3 install -e .\n</code></pre> <ol> <li>Install development dependencies:</li> </ol> <pre><code>pip3 install pytest pytest-cov black flake8 mypy\n</code></pre>"},{"location":"development/#project-structure","title":"Project Structure","text":"<pre><code>evrmore-authentication/\n\u251c\u2500\u2500 evrmore_authentication/    # Main package\n\u2502   \u251c\u2500\u2500 __init__.py            # Package initialization\n\u2502   \u251c\u2500\u2500 auth.py                # Core authentication logic\n\u2502   \u251c\u2500\u2500 api.py                 # FastAPI endpoints\n\u2502   \u251c\u2500\u2500 models.py              # Database models\n\u2502   \u251c\u2500\u2500 exceptions.py          # Custom exceptions\n\u2502   \u2514\u2500\u2500 dependencies.py        # FastAPI dependencies\n\u251c\u2500\u2500 scripts/                   # Utility scripts\n\u2502   \u251c\u2500\u2500 run_api_server.py      # API server runner\n\u2502   \u2514\u2500\u2500 run_web_demo.py        # Web demo runner\n\u251c\u2500\u2500 examples/                  # Example applications\n\u251c\u2500\u2500 tests/                     # Test suite\n\u251c\u2500\u2500 docs/                      # Documentation\n\u2514\u2500\u2500 setup.py                   # Package setup\n</code></pre>"},{"location":"development/#running-tests","title":"Running Tests","text":"<p>Run the test suite:</p> <pre><code>pytest\n</code></pre> <p>Run tests with coverage:</p> <pre><code>pytest --cov=evrmore_authentication\n</code></pre>"},{"location":"development/#code-style","title":"Code Style","text":"<p>This project follows PEP 8 style guidelines. You can check your code with:</p> <pre><code>flake8 evrmore_authentication\n</code></pre> <p>Format your code with:</p> <pre><code>black evrmore_authentication\n</code></pre>"},{"location":"development/#building-documentation","title":"Building Documentation","text":"<p>The documentation is built using MkDocs with the Material theme:</p> <pre><code># Install MkDocs and the Material theme\npip3 install mkdocs-material\n\n# Serve the documentation locally\nmkdocs serve\n\n# Build the documentation\nmkdocs build\n</code></pre>"},{"location":"development/#release-process","title":"Release Process","text":"<ol> <li>Update the version number in <code>setup.py</code></li> <li>Update the changelog</li> <li>Create a new release on GitHub</li> <li>Build and upload the package to PyPI:</li> </ol> <pre><code>python3 -m build\npython3 -m twine upload dist/*\n</code></pre>"},{"location":"development/#contributing-guidelines","title":"Contributing Guidelines","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Make your changes</li> <li>Run tests to ensure they pass</li> <li>Submit a pull request</li> </ol> <p>Please follow these guidelines when contributing:</p> <ul> <li>Write clear, concise commit messages</li> <li>Include tests for new features</li> <li>Update documentation for any changes</li> <li>Follow the existing code style</li> </ul>"},{"location":"development/#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details. </p>"},{"location":"examples/","title":"Examples","text":"<p>This section provides practical examples of using Evrmore Authentication in different scenarios.</p>"},{"location":"examples/#basic-authentication-example","title":"Basic Authentication Example","text":"<pre><code>from evrmore_authentication import EvrmoreAuth\nfrom evrmore_rpc import EvrmoreClient\n\n# Initialize the authentication system\nclient = EvrmoreClient()\nauth = EvrmoreAuth(client)\n\n# Generate a challenge for a user's Evrmore address\nevrmore_address = \"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\"\nchallenge = auth.generate_challenge(evrmore_address)\nprint(f\"Challenge: {challenge}\")\n\n# In a real application, the user would sign this challenge with their wallet\n# For testing, we can use the Evrmore client to sign the message\nsignature = client.signmessage(evrmore_address, challenge)\nprint(f\"Signature: {signature}\")\n\n# Authenticate the user with the signed challenge\nsession = auth.authenticate(evrmore_address, challenge, signature)\nprint(f\"Token: {session.token}\")\nprint(f\"User ID: {session.user_id}\")\nprint(f\"Expires at: {session.expires_at}\")\n\n# Validate the token\npayload = auth.validate_token(session.token)\nprint(f\"Token payload: {payload}\")\n\n# Get the user by token\nuser = auth.get_user_by_token(session.token)\nprint(f\"User: {user.evrmore_address}\")\n\n# Invalidate the token (logout)\nauth.invalidate_token(session.token)\nprint(\"Token invalidated\")\n</code></pre>"},{"location":"examples/#fastapi-integration-example","title":"FastAPI Integration Example","text":"<pre><code>from fastapi import FastAPI, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom evrmore_authentication import EvrmoreAuth, get_current_user\nfrom evrmore_authentication.exceptions import InvalidTokenError, UserNotFoundError\n\napp = FastAPI(title=\"Evrmore Auth API\")\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\nauth = EvrmoreAuth()\n\n@app.post(\"/challenge\")\nasync def generate_challenge(evrmore_address: str):\n    \"\"\"Generate a challenge for a user to sign with their Evrmore wallet.\"\"\"\n    challenge = auth.generate_challenge(evrmore_address)\n    return {\"challenge\": challenge}\n\n@app.post(\"/authenticate\")\nasync def authenticate(evrmore_address: str, challenge: str, signature: str):\n    \"\"\"Authenticate a user with their signed challenge.\"\"\"\n    try:\n        session = auth.authenticate(evrmore_address, challenge, signature)\n        return {\n            \"token\": session.token,\n            \"user_id\": session.user_id,\n            \"evrmore_address\": session.evrmore_address,\n            \"expires_at\": session.expires_at\n        }\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=str(e),\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n@app.get(\"/me\")\nasync def get_current_user_info(current_user = Depends(get_current_user)):\n    \"\"\"Get information about the currently authenticated user.\"\"\"\n    return {\n        \"id\": str(current_user.id),\n        \"evrmore_address\": current_user.evrmore_address,\n        \"username\": current_user.username,\n        \"email\": current_user.email,\n        \"is_active\": current_user.is_active,\n        \"created_at\": current_user.created_at,\n        \"last_login\": current_user.last_login\n    }\n\n@app.post(\"/logout\")\nasync def logout(token: str):\n    \"\"\"Invalidate a JWT token (logout).\"\"\"\n    try:\n        auth.invalidate_token(token)\n        return {\"success\": True}\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=str(e)\n        )\n</code></pre>"},{"location":"examples/#web-application-example","title":"Web Application Example","text":"<p>See the complete web application example in the examples/web_auth_demo directory. </p>"},{"location":"user-guide/","title":"User Guide","text":"<p>This guide explains how to use Evrmore Authentication in your applications.</p>"},{"location":"user-guide/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Installation</li> <li>Configuration</li> <li>Basic Usage</li> <li>FastAPI Integration</li> <li>Security Considerations</li> </ul>"},{"location":"user-guide/#installation","title":"Installation","text":"<pre><code>pip3 install evrmore-authentication\n</code></pre>"},{"location":"user-guide/#configuration","title":"Configuration","text":"<p>Before using Evrmore Authentication, you need to configure both Evrmore RPC and your database connection.</p>"},{"location":"user-guide/#environment-variables","title":"Environment Variables","text":"<p>Set the following environment variables:</p> <pre><code># Evrmore RPC Configuration\nexport EVRMORE_RPC_URL=http://127.0.0.1:8819\nexport EVRMORE_RPC_USER=yourusername\nexport EVRMORE_RPC_PASSWORD=yourpassword\n\n# SQLite Configuration\nexport SQLITE_DB_PATH=./data/evrmore_auth.db\n\n# JWT Configuration\nexport JWT_SECRET=your-secure-secret-key\nexport JWT_ALGORITHM=HS256\nexport JWT_ACCESS_TOKEN_EXPIRE_MINUTES=30\nexport CHALLENGE_EXPIRE_MINUTES=10\n</code></pre>"},{"location":"user-guide/#database-initialization","title":"Database Initialization","text":"<p>Initialize the database tables:</p> <pre><code>from evrmore_authentication.db import init_db\n\n# Create all tables\ninit_db()\n</code></pre>"},{"location":"user-guide/#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/#initializing-the-authentication-system","title":"Initializing the Authentication System","text":"<pre><code>from evrmore_authentication import EvrmoreAuth\n\n# Create an authentication instance\nauth = EvrmoreAuth()\n</code></pre>"},{"location":"user-guide/#authentication-flow","title":"Authentication Flow","text":"<pre><code># 1. Generate a challenge for a user\nchallenge = auth.generate_challenge(evrmore_address=\"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\")\n\n# 2. User signs the challenge with their wallet and sends the signature\nsignature = \"user-provided-signature\"\n\n# 3. Authenticate the user and get a session\ntry:\n    session = auth.authenticate(\n        evrmore_address=\"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\",\n        challenge=challenge,\n        signature=signature\n    )\n\n    # Use the session token for subsequent requests\n    token = session.token\nexcept InvalidSignatureError:\n    # Handle invalid signature\n    pass\nexcept ChallengeExpiredError:\n    # Handle expired challenge\n    pass\n</code></pre>"},{"location":"user-guide/#validating-user-sessions","title":"Validating User Sessions","text":"<pre><code>try:\n    # Validate a JWT token\n    payload = auth.validate_token(token)\n\n    # Get the user associated with a token\n    user = auth.get_user_by_token(token)\nexcept InvalidTokenError:\n    # Handle invalid token\n    pass\n</code></pre>"},{"location":"user-guide/#fastapi-integration","title":"FastAPI Integration","text":"<p>The package provides built-in FastAPI integration:</p> <pre><code>from fastapi import FastAPI, Depends, HTTPException\nfrom evrmore_authentication import get_current_user\n\napp = FastAPI()\n\n@app.get(\"/protected-route\")\nasync def protected_route(current_user = Depends(get_current_user)):\n    return {\"message\": f\"Hello, {current_user.evrmore_address}!\"}\n</code></pre>"},{"location":"user-guide/#security-considerations","title":"Security Considerations","text":""},{"location":"user-guide/#atomicity","title":"Atomicity","text":"<p>All database operations are atomic, meaning they are executed as a single transaction that either succeeds completely or fails completely. This prevents partial updates that could lead to security issues.</p>"},{"location":"user-guide/#challenge-expiry","title":"Challenge Expiry","text":"<p>Challenges expire after a configurable time period (default: 10 minutes) to prevent replay attacks.</p>"},{"location":"user-guide/#one-time-challenges","title":"One-Time Challenges","text":"<p>Each challenge can only be used once and is marked as used after successful authentication.</p>"},{"location":"user-guide/#jwt-best-practices","title":"JWT Best Practices","text":"<ul> <li>Use a strong, unique <code>JWT_SECRET</code> in production</li> <li>Set a reasonable token expiry time</li> <li>Store tokens securely on the client side </li> </ul>"},{"location":"user-guide/debugging/","title":"Debugging Guide &amp; Advanced Features","text":"<p>This guide explains how to use the advanced features and debugging capabilities of Evrmore Authentication.</p>"},{"location":"user-guide/debugging/#debugging-mode","title":"Debugging Mode","text":"<p>Evrmore Authentication includes a detailed debug mode that can help you troubleshoot issues:</p>"},{"location":"user-guide/debugging/#enabling-debug-mode","title":"Enabling Debug Mode","text":"<p>You can enable debug mode in several ways:</p> <ol> <li> <p>Environment Variable:    <pre><code>export EVRMORE_AUTH_DEBUG=true\n</code></pre></p> </li> <li> <p>Direct Initialization:    <pre><code>from evrmore_authentication import EvrmoreAuth\nauth = EvrmoreAuth(debug=True)\n</code></pre></p> </li> </ol> <p>When debug mode is enabled, detailed logging will show: - Challenge generation steps - Challenge ownership details - Signature verification attempts - Database operations - Hook execution details</p>"},{"location":"user-guide/debugging/#utility-scripts","title":"Utility Scripts","text":"<p>Evrmore Authentication comes with several utility scripts to help you manage the system:</p>"},{"location":"user-guide/debugging/#database-management","title":"Database Management","text":"<p>The <code>db_manage.py</code> script provides tools to manage your database:</p> <pre><code># Initialize the database\n./scripts/db_manage.py init\n\n# Show database information\n./scripts/db_manage.py info\n\n# List users\n./scripts/db_manage.py list-users\n\n# List challenges\n./scripts/db_manage.py list-challenges\n\n# List sessions\n./scripts/db_manage.py list-sessions\n\n# Clean up expired records\n./scripts/db_manage.py cleanup\n\n# Check database integrity\n./scripts/db_manage.py check-integrity\n</code></pre>"},{"location":"user-guide/debugging/#managing-challenges","title":"Managing Challenges","text":"<p>You can view, create, and reassign challenges:</p> <pre><code># List challenges for a specific address\n./scripts/db_manage.py list-challenges -a \"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\"\n\n# Create a challenge for an address\n./scripts/db_manage.py create-challenge \"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\"\n\n# Reassign a challenge to a different address\n./scripts/db_manage.py reassign \"Sign this message...\" \"ENewAddressHere\"\n</code></pre>"},{"location":"user-guide/debugging/#signature-verification","title":"Signature Verification","text":"<p>The <code>verify_signature.py</code> script allows you to verify signatures without database interaction:</p> <pre><code># Verify a signature\n./scripts/verify_signature.py verify \"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\" \"message to verify\" \"signature\"\n\n# Generate a challenge format\n./scripts/verify_signature.py challenge \"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\"\n</code></pre>"},{"location":"user-guide/debugging/#event-hooks","title":"Event Hooks","text":"<p>Evrmore Authentication supports event hooks that let you customize the authentication flow:</p> <pre><code>from evrmore_authentication import EvrmoreAuth\n\nauth = EvrmoreAuth()\n\n# Add a hook to run before challenge generation\ndef pre_challenge_hook(address, expire_minutes):\n    print(f\"Generating challenge for {address}\")\n    return {\"custom_data\": \"value\"}\n\nauth.add_hook('pre_challenge', pre_challenge_hook)\n\n# Available hook points:\n# - pre_challenge: Before generating a challenge\n# - post_challenge: After generating a challenge\n# - pre_auth: Before authenticating a user\n# - post_auth: After successful authentication\n# - pre_verify: Before verifying a signature\n# - post_verify: After verifying a signature\n</code></pre>"},{"location":"user-guide/debugging/#advanced-authentication-options","title":"Advanced Authentication Options","text":""},{"location":"user-guide/debugging/#skip-ownership-checks","title":"Skip Ownership Checks","text":"<p>When authenticating, you can skip the challenge ownership check:</p> <pre><code>session = auth.authenticate(\n    evrmore_address=\"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\",\n    challenge=challenge_text,\n    signature=signature,\n    skip_ownership_check=True  # Skip the ownership check\n)\n</code></pre> <p>This is useful when: - You're migrating users from another system - You want to manually verify challenges - You're using a custom challenge format</p>"},{"location":"user-guide/debugging/#direct-signature-verification","title":"Direct Signature Verification","text":"<p>You can verify signatures directly without challenge management:</p> <pre><code># Just verify the signature\nis_valid = auth.verify_signature_only(\n    address=\"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\",\n    message=\"message to verify\",\n    signature=\"signature\"\n)\n</code></pre>"},{"location":"user-guide/debugging/#challenge-management","title":"Challenge Management","text":"<p>You can manually manage challenges using these methods:</p> <pre><code># Get information about a challenge\nchallenge_info = auth.get_challenge_details(challenge_text)\n\n# Reassign a challenge to a different user\nauth.reassign_challenge(\n    challenge_text=\"challenge_text\", \n    new_address=\"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\"\n)\n\n# Create a manual challenge\nchallenge = auth.create_manual_challenge(\n    evrmore_address=\"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\",\n    challenge_text=\"custom challenge text\"  # Optional\n)\n</code></pre>"},{"location":"user-guide/debugging/#database-maintenance","title":"Database Maintenance","text":""},{"location":"user-guide/debugging/#clean-up-expired-records","title":"Clean Up Expired Records","text":"<p>You can clean up expired records programmatically:</p> <pre><code># Clean up expired challenges\nexpired_challenges = auth.cleanup_expired_challenges()\nprint(f\"Removed {expired_challenges} expired challenges\")\n\n# Clean up expired sessions\nexpired_sessions = auth.cleanup_expired_sessions()\nprint(f\"Removed {expired_sessions} expired sessions\")\n</code></pre>"},{"location":"user-guide/debugging/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"user-guide/debugging/#challenge-ownership-errors","title":"Challenge Ownership Errors","text":"<p>If you encounter \"Challenge does not belong to this user\" errors:</p> <ol> <li>Check if the challenge was generated for a different address:</li> </ol> <pre><code>./scripts/db_manage.py list-challenges -a \"correct-address\"\n</code></pre> <ol> <li>Reassign the challenge to the correct user:</li> </ol> <pre><code>./scripts/db_manage.py reassign \"challenge text\" \"correct-address\"\n</code></pre> <p>Or programmatically:</p> <pre><code>auth.reassign_challenge(challenge_text, new_address=\"correct-address\")\n</code></pre>"},{"location":"user-guide/debugging/#signature-verification-failures","title":"Signature Verification Failures","text":"<p>If signature verification fails:</p> <ol> <li>Verify the signature format using the verification tool:</li> </ol> <pre><code>./scripts/verify_signature.py verify \"address\" \"message\" \"signature\"\n</code></pre> <ol> <li>Check if your wallet is using a different message format. Try these options in your code:</li> </ol> <pre><code># Option 1: Skip ownership checks\nsession = auth.authenticate(\n    evrmore_address=address,\n    challenge=challenge,\n    signature=signature,\n    skip_ownership_check=True\n)\n\n# Option 2: Add a custom verification hook\ndef custom_verify_hook(address, message, signature):\n    # Custom verification logic\n    return True  # or False\n\nauth.add_hook('pre_verify', custom_verify_hook)\n</code></pre>"}]}