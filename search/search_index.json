{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Evrmore AuthenticationEvrmore Authentication","text":"<p>Secure blockchain-based authentication using Evrmore wallet signatures</p>"},{"location":"#overview","title":"Overview","text":"<p>Evrmore Authentication is a Python package that provides a secure, blockchain-based authentication system for your applications. It leverages Evrmore wallet signatures to verify user identity without storing passwords.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Blockchain-based Authentication: Uses Evrmore wallet signatures for secure user authentication</li> <li>Challenge-Response Protocol: Generates unique challenges for each authentication attempt</li> <li>Multiple Backend Options: Supports PostgreSQL and Redis as backend storage</li> <li>JWT Support: Issues and validates JSON Web Tokens for authenticated sessions</li> <li>FastAPI Integration: Ready-to-use FastAPI endpoints for authentication</li> <li>Comprehensive Security: Protection against common attack vectors</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># Install the package\npip3 install evrmore-authentication\n\n# Run the API server\npython3 -m scripts.run_api_server --host 0.0.0.0 --port 8000\n\n# Run the web demo\npython3 -m scripts.run_web_demo --port 5000 --api-url http://localhost:8000\n</code></pre>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li>User Guide - Comprehensive guide for using the package</li> <li>API Reference - Detailed technical reference</li> <li>Examples - Code examples and tutorials</li> <li>Development - Contributing to the project</li> </ul>"},{"location":"#authentication-flow","title":"Authentication Flow","text":"<ol> <li>Challenge Generation: The server generates a unique challenge for a user's Evrmore address</li> <li>Signature Creation: The user signs the challenge with their Evrmore wallet</li> <li>Verification: The server verifies the signature against the challenge</li> <li>Token Issuance: Upon successful verification, a JWT token is issued</li> <li>Authentication: The token is used for subsequent API requests</li> </ol>"},{"location":"#about-manticore-technologies","title":"About Manticore Technologies","text":"<p>Manticore Technologies specializes in blockchain integration and development solutions. Visit our website to learn more about our services and projects. </p>"},{"location":"api-reference/","title":"API Reference","text":"<p>This document provides a detailed reference for all the classes, methods, and functions available in the Evrmore Authentication package.</p>"},{"location":"api-reference/#table-of-contents","title":"Table of Contents","text":"<ul> <li>EvrmoreAuth Class</li> <li>UserSession Class</li> <li>Database Models</li> <li>Dependency Utilities</li> <li>Exceptions</li> <li>REST API Server</li> </ul>"},{"location":"api-reference/#evrmoreauth-class","title":"EvrmoreAuth Class","text":"<p>The main class that provides authentication functionality.</p>"},{"location":"api-reference/#constructor","title":"Constructor","text":"<pre><code>EvrmoreAuth(db=None, jwt_secret=None, jwt_algorithm=None)\n</code></pre> <p>Parameters: - <code>db</code> (Session, optional): SQLAlchemy session instance. If not provided, a new session is created. - <code>jwt_secret</code> (str, optional): Secret key for JWT token generation. If not provided, it's taken from environment variables. - <code>jwt_algorithm</code> (str, optional): Algorithm to use for JWT tokens. If not provided, it defaults to \"HS256\".</p> <p>Properties: - <code>evrmore_available</code> (bool): Indicates if the Evrmore node is available.</p>"},{"location":"api-reference/#methods","title":"Methods","text":""},{"location":"api-reference/#generate_challenge","title":"generate_challenge","text":"<pre><code>generate_challenge(evrmore_address, expire_minutes=None)\n</code></pre> <p>Generates a unique challenge for a user to sign.</p> <p>Parameters: - <code>evrmore_address</code> (str): The Evrmore wallet address. - <code>expire_minutes</code> (int, optional): Minutes until the challenge expires. Default from environment variable.</p> <p>Returns: - <code>str</code>: Challenge text to be signed by the user's wallet.</p> <p>Raises: - <code>AuthenticationError</code>: If there is an error generating the challenge.</p>"},{"location":"api-reference/#authenticate","title":"authenticate","text":"<pre><code>authenticate(evrmore_address, challenge, signature, ip_address=None, user_agent=None, token_expire_minutes=None)\n</code></pre> <p>Authenticates a user using their signed challenge.</p> <p>Parameters: - <code>evrmore_address</code> (str): The Evrmore wallet address. - <code>challenge</code> (str): The challenge text that was signed. - <code>signature</code> (str): The signature created by signing the challenge. - <code>ip_address</code> (str, optional): User's IP address. - <code>user_agent</code> (str, optional): User's agent string. - <code>token_expire_minutes</code> (int, optional): Minutes until token expires.</p> <p>Returns: - <code>UserSession</code>: Session data including the JWT token.</p> <p>Raises: - <code>UserNotFoundError</code>: If user with the address is not found. - <code>ChallengeExpiredError</code>: If the challenge has expired. - <code>ChallengeAlreadyUsedError</code>: If the challenge has already been used. - <code>InvalidSignatureError</code>: If signature verification fails. - <code>AuthenticationError</code>: For other authentication errors.</p>"},{"location":"api-reference/#validate_token","title":"validate_token","text":"<pre><code>validate_token(token)\n</code></pre> <p>Validates a JWT token and returns the token payload.</p> <p>Parameters: - <code>token</code> (str): JWT token to validate.</p> <p>Returns: - <code>dict</code>: Token payload data.</p> <p>Raises: - <code>InvalidTokenError</code>: If the token is invalid or expired. - <code>SessionExpiredError</code>: If the session has expired.</p>"},{"location":"api-reference/#get_user_by_token","title":"get_user_by_token","text":"<pre><code>get_user_by_token(token)\n</code></pre> <p>Gets a user by their token.</p> <p>Parameters: - <code>token</code> (str): JWT token to look up.</p> <p>Returns: - <code>User</code>: User object.</p> <p>Raises: - <code>InvalidTokenError</code>: If the token is invalid. - <code>UserNotFoundError</code>: If the user is not found.</p>"},{"location":"api-reference/#invalidate_token","title":"invalidate_token","text":"<pre><code>invalidate_token(token)\n</code></pre> <p>Invalidates a specific token (logout).</p> <p>Parameters: - <code>token</code> (str): JWT token to invalidate.</p> <p>Returns: - <code>bool</code>: True if token was invalidated successfully.</p>"},{"location":"api-reference/#invalidate_all_tokens","title":"invalidate_all_tokens","text":"<pre><code>invalidate_all_tokens(user_id)\n</code></pre> <p>Invalidates all tokens for a specific user (logout from all devices).</p> <p>Parameters: - <code>user_id</code> (str): User ID to invalidate tokens for.</p> <p>Returns: - <code>int</code>: Number of tokens invalidated.</p>"},{"location":"api-reference/#usersession-class","title":"UserSession Class","text":"<p>A dataclass that holds user session information.</p> <pre><code>@dataclass\nclass UserSession:\n    user_id: str\n    evrmore_address: str\n    token: str\n    expires_at: datetime.datetime\n</code></pre>"},{"location":"api-reference/#database-models","title":"Database Models","text":""},{"location":"api-reference/#user","title":"User","text":"<p>Represents an authenticated wallet owner.</p> <p>Fields: - <code>id</code> (UUID): Primary key. - <code>evrmore_address</code> (String): Unique Evrmore address. - <code>username</code> (String, optional): User's username. - <code>email</code> (String, optional): User's email. - <code>is_active</code> (Boolean): Whether the user is active. - <code>created_at</code> (DateTime): When the user was created. - <code>last_login</code> (DateTime, optional): When the user last logged in.</p>"},{"location":"api-reference/#challenge","title":"Challenge","text":"<p>Stores authentication challenges.</p> <p>Fields: - <code>id</code> (UUID): Primary key. - <code>user_id</code> (UUID): Foreign key to User. - <code>challenge_text</code> (Text): The challenge text. - <code>created_at</code> (DateTime): When the challenge was created. - <code>expires_at</code> (DateTime): When the challenge expires. - <code>used</code> (Boolean): Whether the challenge has been used.</p>"},{"location":"api-reference/#session","title":"Session","text":"<p>Stores user authentication sessions.</p> <p>Fields: - <code>id</code> (UUID): Primary key. - <code>user_id</code> (UUID): Foreign key to User. - <code>token</code> (String): JWT token. - <code>token_id</code> (String): The JWT token ID. - <code>created_at</code> (DateTime): When the session was created. - <code>expires_at</code> (DateTime): When the session expires. - <code>is_active</code> (Boolean): Whether the session is active. - <code>ip_address</code> (String, optional): User's IP address. - <code>user_agent</code> (String, optional): User's agent string.</p>"},{"location":"api-reference/#dependency-utilities","title":"Dependency Utilities","text":""},{"location":"api-reference/#get_current_user","title":"get_current_user","text":"<pre><code>async def get_current_user(token: str)\n</code></pre> <p>FastAPI dependency for getting the current authenticated user.</p> <p>Parameters: - <code>token</code> (str): JWT token from HTTP Authorization header.</p> <p>Returns: - <code>User</code>: The current authenticated user.</p> <p>Raises: - <code>HTTPException</code>: If authentication fails.</p>"},{"location":"api-reference/#exceptions","title":"Exceptions","text":"<ul> <li><code>AuthenticationError</code>: Base class for all authentication errors.</li> <li><code>UserNotFoundError</code>: Raised when a user with the given address is not found.</li> <li><code>ChallengeExpiredError</code>: Raised when an authentication challenge has expired.</li> <li><code>ChallengeAlreadyUsedError</code>: Raised when a challenge has already been used.</li> <li><code>InvalidSignatureError</code>: Raised when the signature verification fails.</li> <li><code>SessionExpiredError</code>: Raised when a session has expired.</li> <li><code>InvalidTokenError</code>: Raised when a token is invalid or has been invalidated.</li> <li><code>ConfigurationError</code>: Raised when there's a configuration error.</li> </ul>"},{"location":"api-reference/#rest-api-server","title":"REST API Server","text":"<p>Evrmore Authentication includes a standalone REST API server that can be used to provide authentication services via HTTP endpoints.</p>"},{"location":"api-reference/#api-endpoints","title":"API Endpoints","text":"Endpoint Method Description <code>/challenge</code> POST Generate a challenge for a user <code>/authenticate</code> POST Authenticate with a signed challenge <code>/validate</code> GET Validate a JWT token <code>/me</code> GET Get authenticated user information <code>/logout</code> POST Invalidate a JWT token (logout)"},{"location":"api-reference/core-api/","title":"Core Auth API Reference","text":"<p>This document provides detailed information about the core authentication API in the Evrmore Authentication system.</p>"},{"location":"api-reference/core-api/#core-classes","title":"Core Classes","text":""},{"location":"api-reference/core-api/#evrmoreauth","title":"EvrmoreAuth","text":"<p>The <code>EvrmoreAuth</code> class is the main entry point for the authentication system. It provides methods for challenge generation, authentication, token validation, and more.</p> <pre><code>from evrmore_authentication import EvrmoreAuth\n\n# Initialize with default settings\nauth = EvrmoreAuth()\n\n# Initialize with custom settings\nauth = EvrmoreAuth(\n    jwt_secret=\"your-custom-secret\",\n    jwt_algorithm=\"HS256\",\n    jwt_private_key_path=None,\n    jwt_public_key_path=None,\n    jwt_issuer=\"custom-issuer\",\n    jwt_audience=\"custom-audience\",\n    access_token_expires=60,  # minutes\n    refresh_token_expires=1440,  # minutes\n    debug=False\n)\n</code></pre>"},{"location":"api-reference/core-api/#usersession","title":"UserSession","text":"<p>The <code>UserSession</code> class represents an authenticated user session.</p> <pre><code>@dataclass\nclass UserSession:\n    user_id: str\n    evrmore_address: str\n    token: str\n    expires_at: datetime.datetime\n</code></pre>"},{"location":"api-reference/core-api/#authentication-flow","title":"Authentication Flow","text":""},{"location":"api-reference/core-api/#challenge-generation","title":"Challenge Generation","text":"<p>Generate a challenge for a user to sign with their Evrmore wallet.</p> <pre><code>challenge = auth.generate_challenge(evrmore_address, expire_minutes=15)\n</code></pre> <p>Parameters:</p> Parameter Type Required Default Description <code>evrmore_address</code> string Yes - Evrmore wallet address <code>expire_minutes</code> integer No 15 Challenge expiration time in minutes <p>Returns:</p> <p>A challenge string that the user needs to sign.</p> <p>Errors:</p> <ul> <li><code>ValidationError</code>: If the Evrmore address is invalid</li> <li><code>RateLimitError</code>: If too many challenges have been generated for this address</li> </ul>"},{"location":"api-reference/core-api/#authentication","title":"Authentication","text":"<p>Authenticate a user by verifying their signature against a challenge.</p> <pre><code>session = auth.authenticate(\n    evrmore_address=\"EXaMPLeEvRMoReAddResS\",\n    challenge=\"Sign this message to authenticate: a8f7e9d1c2b3a4f5e6d7c8b9a1f2e3d4\",\n    signature=\"H9LJFkR+a0MFm1jSvmoBZ1wQobuSGPQ2C1TW/m9FVwnQJNjyZLX3ZzOOHI01jEL59YtJFXBH9PnwH...\",\n    token_expire_minutes=30,\n    ip_address=None,\n    user_agent=None,\n    skip_ownership_check=False,\n    scope=\"profile\"\n)\n</code></pre> <p>Parameters:</p> Parameter Type Required Default Description <code>evrmore_address</code> string Yes - Evrmore wallet address <code>challenge</code> string Yes - The challenge text the user signed <code>signature</code> string Yes - Base64-encoded signature of the challenge <code>token_expire_minutes</code> integer No 30 Token expiration time in minutes <code>ip_address</code> string No None IP address for the session <code>user_agent</code> string No None User agent for the session <code>skip_ownership_check</code> boolean No False Skip checking if the challenge belongs to this address <code>scope</code> string No \"profile\" Requested scope for the token <p>Returns:</p> <p>A <code>UserSession</code> object containing the token and session information.</p> <p>Errors:</p> <ul> <li><code>ValidationError</code>: If the Evrmore address is invalid</li> <li><code>ChallengeExpiredError</code>: If the challenge has expired</li> <li><code>ChallengeUsedError</code>: If the challenge has already been used</li> <li><code>InvalidSignatureError</code>: If the signature verification fails</li> </ul>"},{"location":"api-reference/core-api/#token-validation","title":"Token Validation","text":"<p>Validate a JWT token.</p> <pre><code>token_data = auth.validate_token(token)\n</code></pre> <p>Parameters:</p> Parameter Type Required Default Description <code>token</code> string Yes - JWT token to validate <p>Returns:</p> <p>A dictionary containing the token claims if valid, or <code>None</code> if invalid.</p> <p>Example return value:</p> <pre><code>{\n    \"sub\": \"123e4567-e89b-12d3-a456-426614174000\",  # User ID\n    \"evr_address\": \"EXaMPLeEvRMoReAddResS\",\n    \"iat\": 1614556800,  # Issued at timestamp\n    \"exp\": 1614558600,  # Expiration timestamp\n    \"iss\": \"manticore-evrmore-auth\",  # Issuer\n    \"aud\": \"manticore-clients\"  # Audience\n}\n</code></pre>"},{"location":"api-reference/core-api/#getting-user-by-token","title":"Getting User by Token","text":"<p>Retrieve a user by their token.</p> <pre><code>user = auth.get_user_by_token(token)\n</code></pre> <p>Parameters:</p> Parameter Type Required Default Description <code>token</code> string Yes - JWT token to validate <p>Returns:</p> <p>A <code>User</code> object if the token is valid, or raises an exception if invalid.</p>"},{"location":"api-reference/core-api/#token-invalidation-logout","title":"Token Invalidation (Logout)","text":"<p>Invalidate a JWT token.</p> <pre><code>auth.invalidate_token(token)\n</code></pre> <p>Parameters:</p> Parameter Type Required Default Description <code>token</code> string Yes - JWT token to invalidate <p>Returns:</p> <p><code>True</code> if successful, <code>False</code> otherwise.</p>"},{"location":"api-reference/core-api/#invalidate-all-user-tokens","title":"Invalidate All User Tokens","text":"<p>Invalidate all tokens for a user.</p> <pre><code>auth.invalidate_all_tokens(user_id)\n</code></pre> <p>Parameters:</p> Parameter Type Required Default Description <code>user_id</code> string Yes - User ID <p>Returns:</p> <p><code>True</code> if successful, <code>False</code> otherwise.</p>"},{"location":"api-reference/core-api/#signature-verification","title":"Signature Verification","text":""},{"location":"api-reference/core-api/#verify-signature","title":"Verify Signature","text":"<p>Verify a signature against a message and address.</p> <pre><code>is_valid = auth.verify_signature(\n    address=\"EXaMPLeEvRMoReAddResS\",\n    message=\"Message to sign\",\n    signature=\"H9LJFkR+a0MFm1jSvmoBZ1wQobuSGPQ2C1TW/m9FVwnQJNjyZLX3ZzOOHI01jEL59YtJFXBH9PnwH...\",\n    run_hooks=True\n)\n</code></pre> <p>Parameters:</p> Parameter Type Required Default Description <code>address</code> string Yes - Evrmore wallet address <code>message</code> string Yes - Message that was signed <code>signature</code> string Yes - Base64-encoded signature <code>run_hooks</code> boolean No True Whether to run event hooks <p>Returns:</p> <p><code>True</code> if the signature is valid, <code>False</code> otherwise.</p>"},{"location":"api-reference/core-api/#verify-signature-only","title":"Verify Signature Only","text":"<p>Verify a signature without creating a challenge or user.</p> <pre><code>is_valid = auth.verify_signature_only(\n    evrmore_address=\"EXaMPLeEvRMoReAddResS\",\n    message=\"Message to sign\",\n    signature=\"H9LJFkR+a0MFm1jSvmoBZ1wQobuSGPQ2C1TW/m9FVwnQJNjyZLX3ZzOOHI01jEL59YtJFXBH9PnwH...\"\n)\n</code></pre> <p>Parameters:</p> Parameter Type Required Default Description <code>evrmore_address</code> string Yes - Evrmore wallet address <code>message</code> string Yes - Message that was signed <code>signature</code> string Yes - Base64-encoded signature <p>Returns:</p> <p><code>True</code> if the signature is valid, <code>False</code> otherwise.</p>"},{"location":"api-reference/core-api/#user-management","title":"User Management","text":""},{"location":"api-reference/core-api/#get-user-by-id","title":"Get User by ID","text":"<p>Retrieve a user by their ID.</p> <pre><code>user = auth.get_user_by_id(user_id)\n</code></pre> <p>Parameters:</p> Parameter Type Required Default Description <code>user_id</code> string Yes - User ID <p>Returns:</p> <p>A <code>User</code> object if found, or <code>None</code> if not found.</p>"},{"location":"api-reference/core-api/#user-object","title":"User Object","text":"<p>The <code>User</code> object represents a user in the system.</p> <pre><code>@dataclass\nclass User:\n    id: str\n    evrmore_address: str\n    username: Optional[str] = None\n    email: Optional[str] = None\n    is_active: bool = True\n    created_at: datetime.datetime = field(default_factory=datetime.datetime.utcnow)\n    last_login: Optional[datetime.datetime] = None\n</code></pre> <p>Key methods:</p> <pre><code># Create a new user\nuser = User.create(evrmore_address, username=None, email=None)\n\n# Save user to database\nuser.save()\n\n# Get user by ID\nuser = User.get_by_id(user_id)\n\n# Get user by Evrmore address\nuser = User.get_by_address(evrmore_address)\n\n# Convert user to dictionary\nuser_dict = user.to_dict()\n</code></pre>"},{"location":"api-reference/core-api/#challenge-management","title":"Challenge Management","text":""},{"location":"api-reference/core-api/#get-challenge-details","title":"Get Challenge Details","text":"<p>Get details about a challenge.</p> <pre><code>challenge = auth.get_challenge_details(challenge_text)\n</code></pre> <p>Parameters:</p> Parameter Type Required Default Description <code>challenge_text</code> string Yes - Challenge text <p>Returns:</p> <p>A <code>Challenge</code> object if found, or <code>None</code> if not found.</p>"},{"location":"api-reference/core-api/#challenge-object","title":"Challenge Object","text":"<p>The <code>Challenge</code> object represents an authentication challenge.</p> <pre><code>@dataclass\nclass Challenge:\n    id: str\n    user_id: str\n    challenge_text: str\n    expires_at: datetime.datetime\n    used: bool = False\n    created_at: datetime.datetime = field(default_factory=datetime.datetime.utcnow)\n</code></pre> <p>Key methods:</p> <pre><code># Check if challenge is expired\nis_expired = challenge.is_expired\n\n# Get challenge by ID\nchallenge = Challenge.get_by_id(challenge_id)\n\n# Get challenge by text\nchallenge = Challenge.get_by_text(challenge_text)\n\n# Get challenges for a user\nchallenges = Challenge.get_by_user_id(user_id)\n</code></pre>"},{"location":"api-reference/core-api/#create-manual-challenge","title":"Create Manual Challenge","text":"<p>Create a challenge manually.</p> <pre><code>challenge = auth.create_manual_challenge(\n    evrmore_address=\"EXaMPLeEvRMoReAddResS\",\n    challenge_text=None,  # Generated if None\n    expire_minutes=15\n)\n</code></pre> <p>Parameters:</p> Parameter Type Required Default Description <code>evrmore_address</code> string Yes - Evrmore wallet address <code>challenge_text</code> string No None Custom challenge text (generated if None) <code>expire_minutes</code> integer No 15 Challenge expiration time in minutes <p>Returns:</p> <p>A string containing the challenge text.</p>"},{"location":"api-reference/core-api/#reassign-challenge","title":"Reassign Challenge","text":"<p>Reassign a challenge to a different user or address.</p> <pre><code>auth.reassign_challenge(\n    challenge_text=\"Challenge text\",\n    new_user_id=None,\n    new_address=None\n)\n</code></pre> <p>Parameters:</p> Parameter Type Required Default Description <code>challenge_text</code> string Yes - Challenge text <code>new_user_id</code> string No None New user ID <code>new_address</code> string No None New Evrmore address <p>Returns:</p> <p><code>True</code> if successful, <code>False</code> otherwise.</p>"},{"location":"api-reference/core-api/#utility-methods","title":"Utility Methods","text":""},{"location":"api-reference/core-api/#cleanup-expired-challenges","title":"Cleanup Expired Challenges","text":"<p>Remove expired challenges from the database.</p> <pre><code>count = auth.cleanup_expired_challenges()\n</code></pre> <p>Returns:</p> <p>The number of challenges removed.</p>"},{"location":"api-reference/core-api/#cleanup-expired-sessions","title":"Cleanup Expired Sessions","text":"<p>Remove expired sessions from the database.</p> <pre><code>count = auth.cleanup_expired_sessions()\n</code></pre> <p>Returns:</p> <p>The number of sessions removed.</p>"},{"location":"api-reference/core-api/#create-wallet-address","title":"Create Wallet Address","text":"<p>Create a new Evrmore wallet address.</p> <pre><code>address, private_key = auth.create_wallet_address()\n</code></pre> <p>Returns:</p> <p>A tuple containing the Evrmore address and private key.</p>"},{"location":"api-reference/core-api/#sign-message","title":"Sign Message","text":"<p>Sign a message with a private key.</p> <pre><code>signature = auth.sign_message(wif_key, message)\n</code></pre> <p>Parameters:</p> Parameter Type Required Default Description <code>wif_key</code> string Yes - Private key in WIF format <code>message</code> string Yes - Message to sign <p>Returns:</p> <p>A base64-encoded signature.</p>"},{"location":"api-reference/core-api/#error-handling","title":"Error Handling","text":"<pre><code>from evrmore_authentication.exceptions import (\n    AuthenticationError,\n    ValidationError,\n    ChallengeExpiredError,\n    ChallengeUsedError,\n    InvalidSignatureError,\n    RateLimitError\n)\n\ntry:\n    session = auth.authenticate(evrmore_address, challenge, signature)\nexcept ChallengeExpiredError:\n    print(\"Challenge has expired\")\nexcept ChallengeUsedError:\n    print(\"Challenge has already been used\")\nexcept InvalidSignatureError:\n    print(\"Signature verification failed\")\nexcept ValidationError as e:\n    print(f\"Validation error: {str(e)}\")\nexcept AuthenticationError as e:\n    print(f\"Authentication error: {str(e)}\")\n</code></pre>"},{"location":"api-reference/event-hooks/","title":"Event Hooks","text":"<p>The Event Hooks system in Evrmore Authentication allows you to add custom behavior at key points in the authentication flow. This enables you to extend functionality, add logging, integrate with other systems, or implement custom business logic.</p>"},{"location":"api-reference/event-hooks/#overview","title":"Overview","text":"<p>Event hooks are implemented as callback functions that are executed at specific points in the authentication process. You can register hooks for various events and they will be called with relevant context information when those events occur.</p>"},{"location":"api-reference/event-hooks/#available-hook-points","title":"Available Hook Points","text":"<p>The following hook points are available:</p> Hook Point Description Triggered When <code>pre_challenge</code> Before generating a challenge <code>generate_challenge()</code> is called <code>post_challenge</code> After generating a challenge A challenge has been created <code>pre_auth</code> Before authenticating a user <code>authenticate()</code> is called <code>post_auth</code> After successful authentication Authentication succeeds <code>pre_verify</code> Before verifying a signature Signature verification begins <code>post_verify</code> After verifying a signature Signature verification completes <code>pre_token_validate</code> Before validating a token <code>validate_token()</code> is called <code>post_token_validate</code> After validating a token Token validation completes <code>pre_token_invalidate</code> Before invalidating a token <code>invalidate_token()</code> is called <code>post_token_invalidate</code> After invalidating a token Token invalidation completes"},{"location":"api-reference/event-hooks/#registering-hooks","title":"Registering Hooks","text":"<p>Hooks can be registered using the <code>add_hook</code> method or as a decorator:</p>"},{"location":"api-reference/event-hooks/#using-the-method","title":"Using the Method","text":"<pre><code>from evrmore_authentication import EvrmoreAuth\n\nauth = EvrmoreAuth()\n\ndef my_pre_challenge_hook(evrmore_address, expire_minutes):\n    print(f\"Generating challenge for {evrmore_address}\")\n    return {\"custom_data\": \"value\"}  # Optional return value\n\n# Register the hook\nauth.add_hook('pre_challenge', my_pre_challenge_hook)\n</code></pre>"},{"location":"api-reference/event-hooks/#using-the-decorator","title":"Using the Decorator","text":"<pre><code>from evrmore_authentication import EvrmoreAuth\n\nauth = EvrmoreAuth()\n\n@auth.add_hook('post_auth')\ndef post_auth_hook(user, session):\n    print(f\"User {user.evrmore_address} authenticated successfully\")\n    # Perform custom actions after authentication\n    notify_login(user.id)\n</code></pre>"},{"location":"api-reference/event-hooks/#hook-parameters","title":"Hook Parameters","text":"<p>Each hook receives specific parameters relevant to its context:</p>"},{"location":"api-reference/event-hooks/#pre_challenge","title":"<code>pre_challenge</code>","text":"<pre><code>@auth.add_hook('pre_challenge')\ndef pre_challenge_hook(evrmore_address, expire_minutes):\n    \"\"\"\n    evrmore_address: The address for which the challenge is being generated\n    expire_minutes: The expiration time in minutes\n\n    Return value: Can return a dict to modify parameters\n    \"\"\"\n    # Can modify expire_minutes\n    return {\"expire_minutes\": 30}\n</code></pre>"},{"location":"api-reference/event-hooks/#post_challenge","title":"<code>post_challenge</code>","text":"<pre><code>@auth.add_hook('post_challenge')\ndef post_challenge_hook(evrmore_address, challenge, challenge_record):\n    \"\"\"\n    evrmore_address: The address for which the challenge was generated\n    challenge: The challenge text\n    challenge_record: The Challenge object created\n    \"\"\"\n    # No return value expected\n</code></pre>"},{"location":"api-reference/event-hooks/#pre_auth","title":"<code>pre_auth</code>","text":"<pre><code>@auth.add_hook('pre_auth')\ndef pre_auth_hook(evrmore_address, challenge, signature, skip_ownership_check):\n    \"\"\"\n    evrmore_address: The address being authenticated\n    challenge: The challenge text\n    signature: The signature to verify\n    skip_ownership_check: Whether to skip challenge ownership verification\n\n    Return value: Can return a dict to modify parameters\n    \"\"\"\n    return {\"skip_ownership_check\": True}\n</code></pre>"},{"location":"api-reference/event-hooks/#post_auth","title":"<code>post_auth</code>","text":"<pre><code>@auth.add_hook('post_auth')\ndef post_auth_hook(user, session):\n    \"\"\"\n    user: The User object for the authenticated user\n    session: The Session object created\n    \"\"\"\n    # No return value expected\n</code></pre>"},{"location":"api-reference/event-hooks/#pre_verify","title":"<code>pre_verify</code>","text":"<pre><code>@auth.add_hook('pre_verify')\ndef pre_verify_hook(address, message, signature):\n    \"\"\"\n    address: The Evrmore address\n    message: The message (challenge) to verify\n    signature: The signature to verify\n\n    Return value: Can return a dict to modify parameters\n    \"\"\"\n    # Can modify verification parameters\n    return {\"message\": modified_message}\n</code></pre>"},{"location":"api-reference/event-hooks/#post_verify","title":"<code>post_verify</code>","text":"<pre><code>@auth.add_hook('post_verify')\ndef post_verify_hook(address, message, signature, is_valid):\n    \"\"\"\n    address: The Evrmore address\n    message: The message that was verified\n    signature: The signature that was verified\n    is_valid: Boolean indicating if the signature was valid\n    \"\"\"\n    # No return value expected\n</code></pre>"},{"location":"api-reference/event-hooks/#pre_token_validate","title":"<code>pre_token_validate</code>","text":"<pre><code>@auth.add_hook('pre_token_validate')\ndef pre_token_validate_hook(token):\n    \"\"\"\n    token: The token to validate\n\n    Return value: Can return a dict to modify parameters\n    \"\"\"\n    # No modifications typically needed\n    return {}\n</code></pre>"},{"location":"api-reference/event-hooks/#post_token_validate","title":"<code>post_token_validate</code>","text":"<pre><code>@auth.add_hook('post_token_validate')\ndef post_token_validate_hook(token, token_data, is_valid):\n    \"\"\"\n    token: The token that was validated\n    token_data: The decoded token data if valid, None otherwise\n    is_valid: Boolean indicating if the token was valid\n    \"\"\"\n    # No return value expected\n</code></pre>"},{"location":"api-reference/event-hooks/#pre_token_invalidate","title":"<code>pre_token_invalidate</code>","text":"<pre><code>@auth.add_hook('pre_token_invalidate')\ndef pre_token_invalidate_hook(token):\n    \"\"\"\n    token: The token to invalidate\n\n    Return value: Can return a dict to modify parameters\n    \"\"\"\n    # No modifications typically needed\n    return {}\n</code></pre>"},{"location":"api-reference/event-hooks/#post_token_invalidate","title":"<code>post_token_invalidate</code>","text":"<pre><code>@auth.add_hook('post_token_invalidate')\ndef post_token_invalidate_hook(token, session):\n    \"\"\"\n    token: The token that was invalidated\n    session: The Session object that was invalidated\n    \"\"\"\n    # No return value expected\n</code></pre>"},{"location":"api-reference/event-hooks/#multiple-hooks","title":"Multiple Hooks","text":"<p>You can register multiple hooks for the same event. They will be executed in the order they were registered:</p> <pre><code>@auth.add_hook('post_auth')\ndef log_auth(user, session):\n    print(f\"User {user.evrmore_address} authenticated\")\n\n@auth.add_hook('post_auth')\ndef notify_auth(user, session):\n    send_notification(user.id, \"New login detected\")\n</code></pre>"},{"location":"api-reference/event-hooks/#modifying-parameters","title":"Modifying Parameters","text":"<p>Hooks that run before an operation (<code>pre_*</code> hooks) can modify the parameters passed to the operation by returning a dictionary with the modified values:</p> <pre><code>@auth.add_hook('pre_challenge')\ndef extend_challenge_expiry(evrmore_address, expire_minutes):\n    if is_premium_user(evrmore_address):\n        # Premium users get longer-lived challenges\n        return {\"expire_minutes\": 60}\n    return {}  # Return empty dict to keep default parameters\n</code></pre>"},{"location":"api-reference/event-hooks/#practical-examples","title":"Practical Examples","text":""},{"location":"api-reference/event-hooks/#logging-authentication-attempts","title":"Logging Authentication Attempts","text":"<pre><code>@auth.add_hook('pre_auth')\ndef log_auth_attempt(evrmore_address, challenge, signature, skip_ownership_check):\n    print(f\"Authentication attempt by {evrmore_address}\")\n    return {}\n\n@auth.add_hook('post_auth')\ndef log_auth_success(user, session):\n    print(f\"Successful authentication by {user.evrmore_address}\")\n\n@auth.add_hook('post_verify')\ndef log_verification_result(address, message, signature, is_valid):\n    if not is_valid:\n        print(f\"Failed signature verification for {address}\")\n</code></pre>"},{"location":"api-reference/event-hooks/#custom-user-management","title":"Custom User Management","text":"<pre><code>@auth.add_hook('post_auth')\ndef update_user_data(user, session):\n    # Update last login time in a custom database\n    db.execute(\n        \"UPDATE user_metadata SET last_login = ? WHERE user_id = ?\",\n        (datetime.datetime.utcnow().isoformat(), user.id)\n    )\n\n    # Count login attempts\n    login_count = db.fetchone(\n        \"SELECT login_count FROM user_stats WHERE user_id = ?\",\n        (user.id,)\n    )\n\n    if login_count:\n        db.execute(\n            \"UPDATE user_stats SET login_count = login_count + 1 WHERE user_id = ?\",\n            (user.id,)\n        )\n    else:\n        db.execute(\n            \"INSERT INTO user_stats (user_id, login_count) VALUES (?, ?)\",\n            (user.id, 1)\n        )\n</code></pre>"},{"location":"api-reference/event-hooks/#security-enhancements","title":"Security Enhancements","text":"<pre><code>@auth.add_hook('pre_challenge')\ndef rate_limit_challenges(evrmore_address, expire_minutes):\n    # Check if too many challenges have been generated recently\n    count = db.fetchone(\n        \"\"\"SELECT COUNT(*) as count FROM challenges \n        WHERE evrmore_address = ? AND created_at &gt; ?\"\"\",\n        (evrmore_address, (datetime.datetime.utcnow() - datetime.timedelta(minutes=5)).isoformat())\n    )\n\n    if count and count['count'] &gt; 5:\n        raise Exception(\"Rate limit exceeded for challenge generation\")\n\n    return {}\n\n@auth.add_hook('post_auth')\ndef check_suspicious_activity(user, session):\n    # Check if the user has logged in from a new location\n    # Implementation depends on how you track locations\n    current_ip = get_request_ip()\n\n    known_ips = db.fetchall(\n        \"SELECT ip_address FROM user_locations WHERE user_id = ?\",\n        (user.id,)\n    )\n\n    if current_ip not in [row['ip_address'] for row in known_ips]:\n        # New location, store it and notify user\n        db.execute(\n            \"INSERT INTO user_locations (user_id, ip_address, first_seen) VALUES (?, ?, ?)\",\n            (user.id, current_ip, datetime.datetime.utcnow().isoformat())\n        )\n\n        send_notification(user.id, f\"New login from {get_location_from_ip(current_ip)}\")\n</code></pre>"},{"location":"api-reference/event-hooks/#integration-with-external-systems","title":"Integration with External Systems","text":"<pre><code>@auth.add_hook('post_auth')\ndef sync_with_crm(user, session):\n    # Update user in CRM system\n    crm_api.update_user(\n        user_id=user.id,\n        evrmore_address=user.evrmore_address,\n        last_login=datetime.datetime.utcnow().isoformat()\n    )\n\n@auth.add_hook('post_token_invalidate')\ndef update_activity_tracking(token, session):\n    # Log user logout in analytics system\n    analytics.track_event(\n        session.user_id,\n        'user_logout',\n        {\n            'session_duration': (datetime.datetime.utcnow() - session.created_at).total_seconds(),\n            'session_id': session.id\n        }\n    )\n</code></pre>"},{"location":"api-reference/event-hooks/#error-handling","title":"Error Handling","text":"<p>Errors in hooks are logged but do not interrupt the main authentication flow by default. To change this behavior, you can set the <code>propagate_hook_errors</code> parameter when initializing <code>EvrmoreAuth</code>:</p> <pre><code>auth = EvrmoreAuth(propagate_hook_errors=True)\n</code></pre> <p>With this setting, any exception raised in a hook will be propagated to the caller.</p>"},{"location":"api-reference/event-hooks/#testing-hooks","title":"Testing Hooks","text":"<p>To test hooks, you may want to mock the authentication systems:</p> <pre><code>from unittest.mock import patch, MagicMock\n\ndef test_post_auth_hook():\n    auth = EvrmoreAuth()\n\n    # Create a spy to check if the hook was called\n    spy = MagicMock()\n\n    @auth.add_hook('post_auth')\n    def my_hook(user, session):\n        spy(user.id, session.id)\n\n    # Mock authenticate to avoid actual authentication\n    with patch.object(auth, 'authenticate') as mock_auth:\n        # Create mock user and session\n        mock_user = MagicMock()\n        mock_user.id = \"123\"\n        mock_user.evrmore_address = \"EXaMPLeEvRMoReAddResS\"\n\n        mock_session = MagicMock()\n        mock_session.id = \"456\"\n        mock_session.user_id = \"123\"\n\n        # Make authenticate return our mock session\n        mock_auth.return_value = mock_session\n\n        # Call authenticate\n        auth.authenticate(\n            evrmore_address=\"EXaMPLeEvRMoReAddResS\",\n            challenge=\"test_challenge\",\n            signature=\"test_signature\"\n        )\n\n        # Verify hook was called with correct parameters\n        spy.assert_called_once_with(\"123\", \"456\")\n</code></pre>"},{"location":"api-reference/oauth-api/","title":"OAuth 2.0 API Reference","text":"<p>This document provides detailed information about the OAuth 2.0 endpoints available in the Evrmore Authentication system.</p>"},{"location":"api-reference/oauth-api/#oauth-20-endpoints","title":"OAuth 2.0 Endpoints","text":"Endpoint Method Description <code>/oauth/clients</code> POST Register a new OAuth client <code>/oauth/authorize</code> GET/POST Start the authorization process <code>/auth</code> GET HTML authentication page for the OAuth flow <code>/oauth/login</code> POST Authenticate with a signed challenge <code>/oauth/token</code> POST Exchange authorization codes or refresh tokens <code>/oauth/userinfo</code> GET Get the authenticated user's profile <code>/oauth/revoke</code> POST Revoke tokens"},{"location":"api-reference/oauth-api/#client-registration","title":"Client Registration","text":""},{"location":"api-reference/oauth-api/#register-a-new-oauth-client","title":"Register a new OAuth client","text":"<pre><code>POST /oauth/clients\n</code></pre> <p>Request Parameters:</p> Parameter Type Required Description <code>client_name</code> string Yes Display name of the client application <code>redirect_uris</code> array of strings Yes Allowed redirect URIs <code>client_uri</code> string No URI of the client application <code>logo_uri</code> string No URI to the client's logo <code>scopes</code> array of strings No Allowed scopes (defaults to <code>[\"profile\"]</code>) <code>response_types</code> array of strings No Allowed response types (defaults to <code>[\"code\"]</code>) <p>Example Request:</p> <pre><code>{\n  \"client_name\": \"Example App\",\n  \"redirect_uris\": [\"https://example.com/callback\"],\n  \"client_uri\": \"https://example.com\",\n  \"logo_uri\": \"https://example.com/logo.png\",\n  \"scopes\": [\"profile\", \"email\"],\n  \"response_types\": [\"code\"]\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"client_id\": \"d5fdcc0c-7a88-4cfc-a1ff-6af04b92e9b0\",\n  \"client_secret\": \"XBBMQM9kppmbCyT5opG5FCZ0g89osYeKkrlNrmbIfKk\",\n  \"client_name\": \"Example App\",\n  \"redirect_uris\": [\"https://example.com/callback\"],\n  \"client_uri\": \"https://example.com\",\n  \"logo_uri\": \"https://example.com/logo.png\",\n  \"scopes\": [\"profile\", \"email\"],\n  \"response_types\": [\"code\"],\n  \"created_at\": \"2023-03-14T12:00:00Z\"\n}\n</code></pre>"},{"location":"api-reference/oauth-api/#authorization-flow","title":"Authorization Flow","text":""},{"location":"api-reference/oauth-api/#1-initiate-authorization","title":"1. Initiate Authorization","text":"<pre><code>GET /oauth/authorize\n</code></pre> <p>Query Parameters:</p> Parameter Type Required Description <code>client_id</code> string Yes The client identifier <code>redirect_uri</code> string Yes Redirect URI registered with the client <code>response_type</code> string Yes Must be <code>code</code> <code>scope</code> string Yes Space-separated list of requested scopes <code>state</code> string Yes Random string to prevent CSRF attacks <p>Example Request:</p> <pre><code>GET /oauth/authorize?client_id=d5fdcc0c-7a88-4cfc-a1ff-6af04b92e9b0&amp;redirect_uri=https://example.com/callback&amp;response_type=code&amp;scope=profile+email&amp;state=random_state\n</code></pre> <p>Response:</p> <p>The user is redirected to the authentication page (<code>/auth</code>) where they can enter their Evrmore address and sign the challenge.</p>"},{"location":"api-reference/oauth-api/#2-authenticate-with-a-signed-challenge","title":"2. Authenticate with a Signed Challenge","text":"<p>After the user signs the challenge, the client submits:</p> <pre><code>POST /oauth/login\n</code></pre> <p>Request Parameters:</p> Parameter Type Required Description <code>evrmore_address</code> string Yes User's Evrmore address <code>challenge</code> string Yes The challenge text <code>signature</code> string Yes The signature created by the wallet <code>client_id</code> string Yes The client identifier <code>redirect_uri</code> string Yes The redirect URI <code>state</code> string Yes The state parameter <p>Example Request:</p> <pre><code>{\n  \"evrmore_address\": \"EXaMPLeEvRMoReAddResS\",\n  \"challenge\": \"Sign this message to authenticate: a8f7e9d1c2b3a4f5e6d7c8b9a1f2e3d4\",\n  \"signature\": \"H9LJFkR+a0MFm1jSvmoBZ1wQobuSGPQ2C1TW/m9FVwnQJNjyZLX3ZzOOHI01jEL59YtJFXBH9PnwH...\",\n  \"client_id\": \"d5fdcc0c-7a88-4cfc-a1ff-6af04b92e9b0\",\n  \"redirect_uri\": \"https://example.com/callback\",\n  \"state\": \"random_state\"\n}\n</code></pre> <p>Response:</p> <p>The user is redirected to the <code>redirect_uri</code> with an authorization code:</p> <pre><code>https://example.com/callback?code=abcdef123456&amp;state=random_state\n</code></pre>"},{"location":"api-reference/oauth-api/#3-exchange-authorization-code-for-tokens","title":"3. Exchange Authorization Code for Tokens","text":"<pre><code>POST /oauth/token\n</code></pre> <p>Request Parameters (x-www-form-urlencoded):</p> Parameter Type Required Description <code>grant_type</code> string Yes Must be <code>authorization_code</code> <code>code</code> string Yes The authorization code <code>redirect_uri</code> string Yes Must match the original redirect URI <code>client_id</code> string Yes The client identifier <code>client_secret</code> string Yes The client secret <p>Example Request:</p> <pre><code>POST /oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&amp;code=abcdef123456&amp;redirect_uri=https://example.com/callback&amp;client_id=d5fdcc0c-7a88-4cfc-a1ff-6af04b92e9b0&amp;client_secret=XBBMQM9kppmbCyT5opG5FCZ0g89osYeKkrlNrmbIfKk\n</code></pre> <p>Response:</p> <pre><code>{\n  \"access_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\",\n  \"token_type\": \"Bearer\",\n  \"expires_in\": 3600,\n  \"refresh_token\": \"tGzv3JOkF0XG5Qx2TlKWIA...\",\n  \"scope\": \"profile email\"\n}\n</code></pre>"},{"location":"api-reference/oauth-api/#token-operations","title":"Token Operations","text":""},{"location":"api-reference/oauth-api/#get-user-information","title":"Get User Information","text":"<pre><code>GET /oauth/userinfo\n</code></pre> <p>Headers:</p> Header Value Required Description <code>Authorization</code> <code>Bearer {access_token}</code> Yes The access token <p>Example Request:</p> <pre><code>GET /oauth/userinfo\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\n</code></pre> <p>Response:</p> <pre><code>{\n  \"sub\": \"123e4567-e89b-12d3-a456-426614174000\",\n  \"address\": \"EXaMPLeEvRMoReAddResS\",\n  \"preferred_username\": \"User_123e4567\",\n  \"email\": \"user@example.com\",\n  \"email_verified\": false\n}\n</code></pre>"},{"location":"api-reference/oauth-api/#refresh-access-token","title":"Refresh Access Token","text":"<pre><code>POST /oauth/token\n</code></pre> <p>Request Parameters (x-www-form-urlencoded):</p> Parameter Type Required Description <code>grant_type</code> string Yes Must be <code>refresh_token</code> <code>refresh_token</code> string Yes The refresh token <code>client_id</code> string Yes The client identifier <code>client_secret</code> string Yes The client secret <p>Example Request:</p> <pre><code>POST /oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA...&amp;client_id=d5fdcc0c-7a88-4cfc-a1ff-6af04b92e9b0&amp;client_secret=XBBMQM9kppmbCyT5opG5FCZ0g89osYeKkrlNrmbIfKk\n</code></pre> <p>Response:</p> <pre><code>{\n  \"access_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\",\n  \"token_type\": \"Bearer\",\n  \"expires_in\": 3600,\n  \"refresh_token\": \"new_refresh_token...\",\n  \"scope\": \"profile email\"\n}\n</code></pre>"},{"location":"api-reference/oauth-api/#revoke-token","title":"Revoke Token","text":"<pre><code>POST /oauth/revoke\n</code></pre> <p>Request Parameters:</p> Parameter Type Required Description <code>token</code> string Yes The token to revoke (access or refresh) <code>client_id</code> string Yes The client identifier <code>client_secret</code> string Yes The client secret <p>Example Request:</p> <pre><code>{\n  \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\",\n  \"client_id\": \"d5fdcc0c-7a88-4cfc-a1ff-6af04b92e9b0\",\n  \"client_secret\": \"XBBMQM9kppmbCyT5opG5FCZ0g89osYeKkrlNrmbIfKk\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"success\": true\n}\n</code></pre>"},{"location":"api-reference/oauth-api/#error-responses","title":"Error Responses","text":"<p>OAuth endpoints follow standard OAuth 2.0 error responses. For example:</p> <pre><code>{\n  \"error\": \"invalid_request\",\n  \"error_description\": \"Invalid client_id parameter\"\n}\n</code></pre> <p>Common error types:</p> Error Description <code>invalid_request</code> The request is missing a required parameter or is malformed <code>unauthorized_client</code> The client is not authorized to request an authorization code <code>access_denied</code> The resource owner denied the request <code>unsupported_response_type</code> The server does not support the requested response type <code>invalid_scope</code> The requested scope is invalid or unknown <code>server_error</code> An unexpected error occurred on the server <code>temporarily_unavailable</code> The server is temporarily unavailable <code>invalid_client</code> Client authentication failed <code>invalid_grant</code> The authorization code or refresh token is invalid"},{"location":"api-reference/oauth-api/#implementation-notes","title":"Implementation Notes","text":"<ol> <li>All dates/times are in ISO 8601 format (UTC).</li> <li>Access tokens expire after 1 hour by default.</li> <li>Refresh tokens expire after 30 days by default.</li> <li>The <code>/auth</code> endpoint serves an HTML page for the user authentication flow.</li> <li>The state parameter is used to prevent CSRF attacks and should be validated by the client.</li> <li>Client secrets should never be exposed to the browser or other insecure environments. </li> </ol>"},{"location":"api-reference/sqlite/","title":"SQLite Implementation","text":"<p>This document describes how Evrmore Authentication uses SQLite as a backend storage system.</p>"},{"location":"api-reference/sqlite/#overview","title":"Overview","text":"<p>Evrmore Authentication uses SQLite as a lightweight, file-based database that requires no external server. SQLite provides a simple and reliable way to store and retrieve session data, user information, and authentication challenges.</p>"},{"location":"api-reference/sqlite/#database-schema","title":"Database Schema","text":"<p>The SQLite implementation uses a simple relational database schema with the following tables:</p> Table Description <code>users</code> Stores user data <code>challenges</code> Stores authentication challenges <code>sessions</code> Stores user sessions and tokens"},{"location":"api-reference/sqlite/#table-schemas","title":"Table Schemas","text":""},{"location":"api-reference/sqlite/#users-table","title":"Users Table","text":"<pre><code>CREATE TABLE IF NOT EXISTS users (\n    id TEXT PRIMARY KEY,\n    evrmore_address TEXT UNIQUE NOT NULL,\n    username TEXT,\n    email TEXT,\n    is_active INTEGER NOT NULL DEFAULT 1,\n    created_at TEXT NOT NULL,\n    last_login TEXT\n)\n</code></pre>"},{"location":"api-reference/sqlite/#challenges-table","title":"Challenges Table","text":"<pre><code>CREATE TABLE IF NOT EXISTS challenges (\n    id TEXT PRIMARY KEY,\n    user_id TEXT NOT NULL,\n    challenge_text TEXT NOT NULL,\n    expires_at TEXT NOT NULL,\n    used INTEGER NOT NULL DEFAULT 0,\n    created_at TEXT NOT NULL,\n    FOREIGN KEY (user_id) REFERENCES users (id)\n)\n</code></pre>"},{"location":"api-reference/sqlite/#sessions-table","title":"Sessions Table","text":"<pre><code>CREATE TABLE IF NOT EXISTS sessions (\n    id TEXT PRIMARY KEY,\n    user_id TEXT NOT NULL,\n    token TEXT NOT NULL,\n    expires_at TEXT NOT NULL,\n    is_active INTEGER NOT NULL DEFAULT 1,\n    created_at TEXT NOT NULL,\n    ip_address TEXT,\n    user_agent TEXT,\n    FOREIGN KEY (user_id) REFERENCES users (id)\n)\n</code></pre>"},{"location":"api-reference/sqlite/#data-models","title":"Data Models","text":"<p>The SQLite implementation uses dataclass models to represent the database tables:</p>"},{"location":"api-reference/sqlite/#user-model","title":"User Model","text":"<pre><code>@dataclass\nclass User:\n    id: str\n    evrmore_address: str\n    username: Optional[str] = None\n    email: Optional[str] = None\n    is_active: bool = True\n    created_at: datetime.datetime = field(default_factory=datetime.datetime.utcnow)\n    last_login: Optional[datetime.datetime] = None\n</code></pre>"},{"location":"api-reference/sqlite/#challenge-model","title":"Challenge Model","text":"<pre><code>@dataclass\nclass Challenge:\n    id: str\n    user_id: str\n    challenge_text: str\n    expires_at: datetime.datetime\n    used: bool = False\n    created_at: datetime.datetime = field(default_factory=datetime.datetime.utcnow)\n</code></pre>"},{"location":"api-reference/sqlite/#session-model","title":"Session Model","text":"<pre><code>@dataclass\nclass Session:\n    id: str\n    user_id: str\n    token: str\n    expires_at: datetime.datetime\n    is_active: bool = True\n    created_at: datetime.datetime = field(default_factory=datetime.datetime.utcnow)\n    ip_address: Optional[str] = None\n    user_agent: Optional[str] = None\n</code></pre>"},{"location":"api-reference/sqlite/#handling-datetime-objects","title":"Handling Datetime Objects","text":"<p>SQLite doesn't natively support datetime objects, so they are stored as ISO format strings in the database and converted back to datetime objects when retrieving them.</p> <pre><code>def to_dict(self):\n    \"\"\"Convert User to a dictionary.\"\"\"\n    return {\n        \"id\": str(self.id),\n        \"evrmore_address\": self.evrmore_address,\n        \"username\": self.username,\n        \"email\": self.email,\n        \"is_active\": self.is_active,\n        \"created_at\": self.created_at.isoformat() if self.created_at else None,\n        \"last_login\": self.last_login.isoformat() if self.last_login else None\n    }\n</code></pre>"},{"location":"api-reference/sqlite/#database-connections","title":"Database Connections","text":"<p>The SQLite implementation uses a singleton pattern to manage database connections, ensuring that only one connection is active at a time:</p> <pre><code>class SQLiteManager:\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super(SQLiteManager, cls).__new__(cls)\n            cls._instance.initialized = False\n        return cls._instance\n\n    def __init__(self):\n        if not self.initialized:\n            db_path = os.environ.get('SQLITE_DB_PATH', './data/evrmore_auth.db')\n\n            # Create data directory if it doesn't exist\n            db_dir = os.path.dirname(db_path)\n            if db_dir and not os.path.exists(db_dir):\n                os.makedirs(db_dir, exist_ok=True)\n\n            self.conn = sqlite3.connect(db_path, check_same_thread=False)\n            self.conn.row_factory = sqlite3.Row\n            self._create_tables()\n            self.initialized = True\n</code></pre>"},{"location":"api-reference/sqlite/#configuration-options","title":"Configuration Options","text":"<p>SQLite connection settings can be configured using environment variables:</p> <pre><code>SQLITE_DB_PATH=./data/evrmore_auth.db  # Path to the SQLite database file\n</code></pre>"},{"location":"development/","title":"Development Guide","text":"<p>This guide provides information for developers who want to contribute to the Evrmore Authentication project.</p>"},{"location":"development/#setting-up-the-development-environment","title":"Setting Up the Development Environment","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/manticoretechnologies/evrmore-authentication.git\ncd evrmore-authentication\n</code></pre> <ol> <li>Create a virtual environment:</li> </ol> <pre><code>python3 -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n</code></pre> <ol> <li>Install the package in development mode:</li> </ol> <pre><code>pip3 install -e .\n</code></pre> <ol> <li>Install development dependencies:</li> </ol> <pre><code>pip3 install pytest pytest-cov black flake8 mypy\n</code></pre>"},{"location":"development/#project-structure","title":"Project Structure","text":"<pre><code>evrmore-authentication/\n\u251c\u2500\u2500 evrmore_authentication/    # Main package\n\u2502   \u251c\u2500\u2500 __init__.py            # Package initialization\n\u2502   \u251c\u2500\u2500 auth.py                # Core authentication logic\n\u2502   \u251c\u2500\u2500 api.py                 # FastAPI endpoints\n\u2502   \u251c\u2500\u2500 models.py              # Database models\n\u2502   \u251c\u2500\u2500 exceptions.py          # Custom exceptions\n\u2502   \u2514\u2500\u2500 dependencies.py        # FastAPI dependencies\n\u251c\u2500\u2500 scripts/                   # Utility scripts\n\u2502   \u251c\u2500\u2500 run_api_server.py      # API server runner\n\u2502   \u2514\u2500\u2500 run_web_demo.py        # Web demo runner\n\u251c\u2500\u2500 examples/                  # Example applications\n\u251c\u2500\u2500 tests/                     # Test suite\n\u251c\u2500\u2500 docs/                      # Documentation\n\u2514\u2500\u2500 setup.py                   # Package setup\n</code></pre>"},{"location":"development/#running-tests","title":"Running Tests","text":"<p>Run the test suite:</p> <pre><code>pytest\n</code></pre> <p>Run tests with coverage:</p> <pre><code>pytest --cov=evrmore_authentication\n</code></pre>"},{"location":"development/#code-style","title":"Code Style","text":"<p>This project follows PEP 8 style guidelines. You can check your code with:</p> <pre><code>flake8 evrmore_authentication\n</code></pre> <p>Format your code with:</p> <pre><code>black evrmore_authentication\n</code></pre>"},{"location":"development/#building-documentation","title":"Building Documentation","text":"<p>The documentation is built using MkDocs with the Material theme:</p> <pre><code># Install MkDocs and the Material theme\npip3 install mkdocs-material\n\n# Serve the documentation locally\nmkdocs serve\n\n# Build the documentation\nmkdocs build\n</code></pre>"},{"location":"development/#release-process","title":"Release Process","text":"<ol> <li>Update the version number in <code>setup.py</code></li> <li>Update the changelog</li> <li>Create a new release on GitHub</li> <li>Build and upload the package to PyPI:</li> </ol> <pre><code>python3 -m build\npython3 -m twine upload dist/*\n</code></pre>"},{"location":"development/#contributing-guidelines","title":"Contributing Guidelines","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Make your changes</li> <li>Run tests to ensure they pass</li> <li>Submit a pull request</li> </ol> <p>Please follow these guidelines when contributing:</p> <ul> <li>Write clear, concise commit messages</li> <li>Include tests for new features</li> <li>Update documentation for any changes</li> <li>Follow the existing code style</li> </ul>"},{"location":"development/#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details. </p>"},{"location":"development/contributing/","title":"Contributing Guide","text":"<p>Thank you for your interest in contributing to the Evrmore Authentication project! This guide will help you get started with contributing to the project, whether you're fixing bugs, adding features, improving documentation, or helping in other ways.</p>"},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>By participating in this project, you agree to abide by our Code of Conduct. Please read it before contributing.</p>"},{"location":"development/contributing/#getting-started","title":"Getting Started","text":""},{"location":"development/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8 or higher</li> <li>Git</li> <li>Basic knowledge of Python and authentication systems</li> <li>Familiarity with Evrmore blockchain (helpful but not required)</li> </ul>"},{"location":"development/contributing/#setting-up-your-development-environment","title":"Setting Up Your Development Environment","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork locally:    <pre><code>git clone https://github.com/your-username/evrmore-authentication.git\ncd evrmore-authentication\n</code></pre></li> <li>Create a virtual environment and install dependencies:    <pre><code>python3 -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\npip3 install -e \".[dev]\"  # Install package in development mode with dev dependencies\n</code></pre></li> <li>Set up pre-commit hooks:    <pre><code>pre-commit install\n</code></pre></li> </ol>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"development/contributing/#branching-strategy","title":"Branching Strategy","text":"<p>We use a simplified Git workflow:</p> <ul> <li><code>main</code> branch is the stable branch with released code</li> <li>Feature branches are created from <code>main</code> and merged back via pull requests</li> </ul>"},{"location":"development/contributing/#creating-a-branch","title":"Creating a Branch","text":"<p>Create a new branch for your work:</p> <pre><code>git checkout -b feature/your-feature-name\n# or\ngit checkout -b fix/your-bug-fix\n</code></pre> <p>Use a descriptive name that reflects the purpose of your changes.</p>"},{"location":"development/contributing/#making-changes","title":"Making Changes","text":"<ol> <li>Make your changes to the codebase</li> <li>Write or update tests to cover your changes</li> <li>Run the tests to ensure they pass:    <pre><code>python3 -m pytest\n</code></pre></li> <li>Run the linter to ensure code quality:    <pre><code>flake8 evrmore_authentication\n</code></pre></li> <li>Format your code:    <pre><code>black evrmore_authentication\n</code></pre></li> </ol>"},{"location":"development/contributing/#committing-changes","title":"Committing Changes","text":"<p>Follow these guidelines for commit messages:</p> <ul> <li>Use the present tense (\"Add feature\" not \"Added feature\")</li> <li>Use the imperative mood (\"Move cursor to...\" not \"Moves cursor to...\")</li> <li>Limit the first line to 72 characters or less</li> <li>Reference issues and pull requests after the first line</li> </ul> <p>Example: <pre><code>Add OAuth token refresh functionality\n\n- Implement refresh token generation\n- Add token refresh endpoint\n- Update documentation\n\nFixes #123\n</code></pre></p>"},{"location":"development/contributing/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<ol> <li>Push your branch to your fork:    <pre><code>git push origin feature/your-feature-name\n</code></pre></li> <li>Go to the original repository on GitHub and create a pull request</li> <li>Fill in the pull request template with details about your changes</li> <li>Wait for a maintainer to review your pull request</li> <li>Address any feedback and make necessary changes</li> <li>Once approved, your pull request will be merged</li> </ol>"},{"location":"development/contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>A good pull request:</p> <ul> <li>Focuses on a single feature or bug fix</li> <li>Includes tests for new functionality or bug fixes</li> <li>Updates documentation to reflect changes</li> <li>Follows the code style of the project</li> <li>Has a clear and descriptive title and description</li> <li>Passes all CI checks</li> </ul>"},{"location":"development/contributing/#testing","title":"Testing","text":"<p>Please refer to the Testing Guide for detailed information on writing and running tests.</p>"},{"location":"development/contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npython3 -m pytest\n\n# Run tests with coverage\npython3 -m pytest --cov=evrmore_authentication\n\n# Run specific tests\npython3 -m pytest evrmore_authentication/tests/unit/test_auth.py\n</code></pre>"},{"location":"development/contributing/#documentation","title":"Documentation","text":"<p>Good documentation is crucial for the project. Please update the documentation when you make changes to the code.</p>"},{"location":"development/contributing/#documentation-structure","title":"Documentation Structure","text":"<ul> <li>API reference documentation is in the <code>docs/api-reference/</code> directory</li> <li>User guides are in the <code>docs/user-guide/</code> directory</li> <li>Examples are in the <code>docs/examples/</code> directory</li> <li>Development guides are in the <code>docs/development/</code> directory</li> </ul>"},{"location":"development/contributing/#building-documentation","title":"Building Documentation","text":"<p>We use MkDocs for documentation. To build and preview the documentation:</p> <pre><code># Install MkDocs and dependencies\npip3 install mkdocs mkdocs-material\n\n# Build and serve documentation locally\nmkdocs serve\n</code></pre> <p>Then open your browser to <code>http://localhost:8000</code> to preview the documentation.</p>"},{"location":"development/contributing/#code-style","title":"Code Style","text":"<p>We follow the Black code style with a line length of 88 characters. We also use isort for import sorting and flake8 for linting.</p>"},{"location":"development/contributing/#automatic-formatting","title":"Automatic Formatting","text":"<pre><code># Format code with Black\nblack evrmore_authentication\n\n# Sort imports with isort\nisort evrmore_authentication\n</code></pre>"},{"location":"development/contributing/#linting","title":"Linting","text":"<pre><code># Run flake8\nflake8 evrmore_authentication\n</code></pre>"},{"location":"development/contributing/#security-considerations","title":"Security Considerations","text":"<p>Security is a top priority for this project. Please follow these guidelines:</p> <ul> <li>Never commit sensitive information (private keys, passwords, etc.)</li> <li>Use secure cryptographic practices</li> <li>Validate all user inputs</li> <li>Follow the principle of least privilege</li> <li>Report security vulnerabilities privately (see Security Policy)</li> </ul>"},{"location":"development/contributing/#feature-requests-and-bug-reports","title":"Feature Requests and Bug Reports","text":"<p>If you have a feature request or have found a bug, please open an issue on GitHub. Use the appropriate issue template and provide as much detail as possible.</p>"},{"location":"development/contributing/#issue-templates","title":"Issue Templates","text":"<ul> <li>Bug Report: For reporting bugs or unexpected behavior</li> <li>Feature Request: For suggesting new features or improvements</li> <li>Documentation Issue: For reporting issues with documentation</li> </ul>"},{"location":"development/contributing/#community","title":"Community","text":"<p>Join our community to get help, share ideas, and collaborate:</p> <ul> <li>GitHub Discussions: For general questions and discussions</li> <li>Issue Tracker: For bug reports and feature requests</li> <li>Discord: Join our Discord server</li> </ul>"},{"location":"development/contributing/#release-process","title":"Release Process","text":"<p>The release process is handled by the maintainers. If you're interested in the release process, please refer to the Release Guide.</p>"},{"location":"development/contributing/#acknowledgments","title":"Acknowledgments","text":"<p>Contributors will be acknowledged in the project's README and release notes. We appreciate all contributions, big or small!</p>"},{"location":"development/contributing/#license","title":"License","text":"<p>By contributing to this project, you agree that your contributions will be licensed under the project's license. See the LICENSE file for details.</p>"},{"location":"development/contributing/#contact","title":"Contact","text":"<p>If you have any questions or need help, you can reach out to the maintainers:</p> <ul> <li>Email: dev@manticore.technology</li> <li>GitHub: @manticoretechnologies</li> </ul> <p>Thank you for contributing to Evrmore Authentication! </p>"},{"location":"development/release-process/","title":"Release Process","text":"<p>This document outlines the release process for the Evrmore Authentication system. It is intended for maintainers and contributors who are involved in preparing and publishing releases.</p>"},{"location":"development/release-process/#version-numbering","title":"Version Numbering","text":"<p>The Evrmore Authentication system follows Semantic Versioning (SemVer):</p> <ul> <li>MAJOR version for incompatible API changes</li> <li>MINOR version for new functionality in a backward-compatible manner</li> <li>PATCH version for backward-compatible bug fixes</li> </ul> <p>Example: <code>1.2.3</code> represents major version 1, minor version 2, and patch version 3.</p>"},{"location":"development/release-process/#release-cycle","title":"Release Cycle","text":"<p>The project follows a time-based release cycle with the following targets:</p> <ul> <li>Major releases: Approximately once per year</li> <li>Minor releases: Every 1-3 months</li> <li>Patch releases: As needed for bug fixes and security updates</li> </ul>"},{"location":"development/release-process/#release-preparation","title":"Release Preparation","text":""},{"location":"development/release-process/#1-create-a-release-branch","title":"1. Create a Release Branch","text":"<p>For minor and major releases, create a release branch from the <code>main</code> branch:</p> <pre><code>git checkout main\ngit pull\ngit checkout -b release/vX.Y.0\n</code></pre> <p>For patch releases, create a release branch from the previous release tag:</p> <pre><code>git checkout vX.Y.0\ngit checkout -b release/vX.Y.Z\n</code></pre>"},{"location":"development/release-process/#2-update-version-numbers","title":"2. Update Version Numbers","text":"<p>Update the version number in the following files:</p> <ul> <li><code>setup.py</code></li> <li><code>evrmore_authentication/__init__.py</code></li> <li><code>docs/index.md</code></li> </ul>"},{"location":"development/release-process/#3-update-changelog","title":"3. Update Changelog","text":"<p>Update the <code>CHANGELOG.md</code> file with the changes since the last release:</p> <ul> <li>New features</li> <li>Bug fixes</li> <li>Performance improvements</li> <li>Security updates</li> <li>Breaking changes (if any)</li> <li>Deprecations (if any)</li> </ul> <p>Use the following format:</p> <pre><code>## [X.Y.Z] - YYYY-MM-DD\n\n### Added\n- New feature 1\n- New feature 2\n\n### Changed\n- Change 1\n- Change 2\n\n### Fixed\n- Bug fix 1\n- Bug fix 2\n\n### Security\n- Security fix 1\n- Security fix 2\n</code></pre>"},{"location":"development/release-process/#4-update-documentation","title":"4. Update Documentation","text":"<p>Ensure that the documentation is up-to-date:</p> <ul> <li>Update API references for any new or changed functionality</li> <li>Update user guides for any changes in behavior</li> <li>Update examples to reflect the latest API</li> <li>Build and verify the documentation:   <pre><code>mkdocs build\n</code></pre></li> </ul>"},{"location":"development/release-process/#5-run-tests","title":"5. Run Tests","text":"<p>Run the full test suite to ensure everything is working correctly:</p> <pre><code>python3 -m pytest\n</code></pre>"},{"location":"development/release-process/#6-create-a-pull-request","title":"6. Create a Pull Request","text":"<p>Create a pull request from the release branch to the <code>main</code> branch. The pull request should include:</p> <ul> <li>Version number updates</li> <li>Changelog updates</li> <li>Documentation updates</li> <li>Any last-minute bug fixes</li> </ul> <p>Request reviews from other maintainers.</p>"},{"location":"development/release-process/#release-process_1","title":"Release Process","text":""},{"location":"development/release-process/#1-merge-the-release-pull-request","title":"1. Merge the Release Pull Request","text":"<p>Once the pull request has been approved, merge it into the <code>main</code> branch.</p>"},{"location":"development/release-process/#2-create-a-release-tag","title":"2. Create a Release Tag","text":"<p>Create a tag for the release:</p> <pre><code>git checkout main\ngit pull\ngit tag -a vX.Y.Z -m \"Release vX.Y.Z\"\ngit push origin vX.Y.Z\n</code></pre>"},{"location":"development/release-process/#3-create-a-github-release","title":"3. Create a GitHub Release","text":"<p>Create a new release on GitHub:</p> <ol> <li>Go to the Releases page</li> <li>Click \"Draft a new release\"</li> <li>Select the tag you just created</li> <li>Set the title to \"Evrmore Authentication vX.Y.Z\"</li> <li>Copy the relevant section from the changelog into the description</li> <li>If it's a pre-release, check the \"This is a pre-release\" box</li> <li>Click \"Publish release\"</li> </ol>"},{"location":"development/release-process/#4-build-and-publish-to-pypi","title":"4. Build and Publish to PyPI","text":"<p>Build the distribution packages:</p> <pre><code>python3 -m pip install --upgrade build\npython3 -m build\n</code></pre> <p>Upload the packages to PyPI:</p> <pre><code>python3 -m pip install --upgrade twine\npython3 -m twine upload dist/*\n</code></pre>"},{"location":"development/release-process/#5-update-documentation","title":"5. Update Documentation","text":"<p>Build and deploy the documentation:</p> <pre><code>mkdocs gh-deploy\n</code></pre>"},{"location":"development/release-process/#6-announce-the-release","title":"6. Announce the Release","text":"<p>Announce the release on:</p> <ul> <li>GitHub Discussions</li> <li>Project website</li> <li>Social media channels</li> <li>Relevant community forums</li> </ul>"},{"location":"development/release-process/#post-release","title":"Post-Release","text":""},{"location":"development/release-process/#1-update-development-version","title":"1. Update Development Version","text":"<p>After the release, update the version number in the <code>main</code> branch to the next development version:</p> <pre><code>git checkout main\n</code></pre> <p>Update the version number in:</p> <ul> <li><code>setup.py</code></li> <li><code>evrmore_authentication/__init__.py</code></li> </ul> <p>Add <code>.dev0</code> to the version number to indicate that it's a development version:</p> <pre><code>__version__ = \"X.Y+1.0.dev0\"  # For a minor release\n__version__ = \"X+1.0.0.dev0\"  # For a major release\n</code></pre> <p>Commit and push the changes:</p> <pre><code>git add .\ngit commit -m \"Bump version to X.Y+1.0.dev0\"\ngit push origin main\n</code></pre>"},{"location":"development/release-process/#2-close-milestone","title":"2. Close Milestone","text":"<p>If you're using GitHub milestones to track progress, close the milestone for the released version and create a new one for the next version.</p>"},{"location":"development/release-process/#hotfix-process","title":"Hotfix Process","text":"<p>For critical bug fixes that need to be released outside the normal release cycle:</p> <ol> <li> <p>Create a hotfix branch from the latest release tag:    <pre><code>git checkout vX.Y.Z\ngit checkout -b hotfix/issue-description\n</code></pre></p> </li> <li> <p>Fix the issue and commit the changes.</p> </li> <li> <p>Update the version number and changelog.</p> </li> <li> <p>Create a pull request to the <code>main</code> branch.</p> </li> <li> <p>After merging, follow the normal release process for a patch release.</p> </li> </ol>"},{"location":"development/release-process/#release-checklist","title":"Release Checklist","text":"<p>Use this checklist to ensure you've completed all the necessary steps:</p> <ul> <li> Create release branch</li> <li> Update version numbers</li> <li> Update changelog</li> <li> Update documentation</li> <li> Run tests</li> <li> Create pull request</li> <li> Merge pull request</li> <li> Create release tag</li> <li> Create GitHub release</li> <li> Build and publish to PyPI</li> <li> Deploy documentation</li> <li> Announce the release</li> <li> Update development version</li> <li> Close milestone</li> </ul>"},{"location":"development/release-process/#additional-resources","title":"Additional Resources","text":"<ul> <li>Semantic Versioning</li> <li>Python Packaging User Guide</li> <li>Twine Documentation</li> <li>MkDocs Documentation </li> </ul>"},{"location":"development/security/","title":"Security Policy and Guidelines","text":"<p>Security is a critical aspect of the Evrmore Authentication system. This document outlines our security policies, best practices, and guidelines for both users and contributors.</p>"},{"location":"development/security/#reporting-security-vulnerabilities","title":"Reporting Security Vulnerabilities","text":"<p>If you discover a security vulnerability in the Evrmore Authentication system, please follow these steps:</p> <ol> <li>Do not disclose the vulnerability publicly until it has been addressed by the maintainers.</li> <li>Email the details to dev@manticore.technology with the subject line \"Security Vulnerability: Evrmore Authentication\".</li> <li>Include the following information in your report:</li> <li>Description of the vulnerability</li> <li>Steps to reproduce</li> <li>Potential impact</li> <li>Suggested fix (if available)</li> <li>The maintainers will acknowledge receipt of your report within 48 hours.</li> <li>You will receive updates on the progress of addressing the vulnerability.</li> <li>Once the vulnerability is fixed, you will be credited for the discovery (unless you request anonymity).</li> </ol>"},{"location":"development/security/#security-model","title":"Security Model","text":"<p>The Evrmore Authentication system is designed with the following security principles:</p>"},{"location":"development/security/#authentication-flow-security","title":"Authentication Flow Security","text":"<ol> <li>Challenge-Response Mechanism: The system uses a cryptographic challenge-response mechanism to verify ownership of Evrmore addresses.</li> <li>Signature Verification: Signatures are verified using the Evrmore blockchain's cryptographic functions.</li> <li>Time-Limited Challenges: Challenges expire after a configurable time period to prevent replay attacks.</li> <li>Single-Use Challenges: Each challenge can only be used once for authentication.</li> </ol>"},{"location":"development/security/#token-security","title":"Token Security","text":"<ol> <li>JWT Standards: The system uses JSON Web Tokens (JWT) that follow industry standards.</li> <li>Configurable Expiration: Token expiration times are configurable to balance security and user experience.</li> <li>Token Invalidation: Tokens can be invalidated for logout or security purposes.</li> <li>Refresh Token Rotation: When using refresh tokens, they are rotated on each use to prevent token theft.</li> </ol>"},{"location":"development/security/#oauth-20-security","title":"OAuth 2.0 Security","text":"<ol> <li>Standard OAuth Flows: The system implements standard OAuth 2.0 flows with security best practices.</li> <li>PKCE Support: Support for Proof Key for Code Exchange (PKCE) to secure authorization code flow.</li> <li>State Parameter: Required state parameter to prevent CSRF attacks.</li> <li>Scope Validation: Strict validation of requested scopes.</li> <li>Redirect URI Validation: Strict validation of redirect URIs against registered values.</li> </ol>"},{"location":"development/security/#security-best-practices-for-deployment","title":"Security Best Practices for Deployment","text":"<p>When deploying the Evrmore Authentication system, follow these best practices:</p>"},{"location":"development/security/#environment-security","title":"Environment Security","text":"<ol> <li>Use HTTPS: Always deploy the authentication server with HTTPS in production.</li> <li>Secure Secrets: Store JWT secrets and other sensitive configuration in secure environment variables or a secrets manager.</li> <li>Principle of Least Privilege: Run the service with the minimum required permissions.</li> <li>Firewall Configuration: Restrict network access to the authentication server as appropriate.</li> </ol>"},{"location":"development/security/#configuration-security","title":"Configuration Security","text":"<ol> <li>JWT Secret: Use a strong, unique secret for JWT signing or, preferably, use asymmetric keys.</li> <li>Token Expiration: Set appropriate token expiration times (recommended: access tokens 15-60 minutes, refresh tokens 1-14 days).</li> <li>Rate Limiting: Enable rate limiting to prevent brute force attacks.</li> <li>Database Security: Secure the database with proper authentication and encryption.</li> </ol>"},{"location":"development/security/#monitoring-and-logging","title":"Monitoring and Logging","text":"<ol> <li>Security Logging: Enable security event logging for authentication attempts, token issuance, and other security-relevant events.</li> <li>Log Protection: Ensure logs don't contain sensitive information and are protected from unauthorized access.</li> <li>Monitoring: Set up monitoring for unusual authentication patterns or potential attacks.</li> <li>Alerts: Configure alerts for suspicious activities.</li> </ol>"},{"location":"development/security/#security-guidelines-for-developers","title":"Security Guidelines for Developers","text":"<p>If you're contributing to the Evrmore Authentication system, follow these security guidelines:</p>"},{"location":"development/security/#code-security","title":"Code Security","text":"<ol> <li>Input Validation: Validate all user inputs, including Evrmore addresses, signatures, and OAuth parameters.</li> <li>Output Encoding: Properly encode outputs to prevent injection attacks.</li> <li>Dependency Management: Keep dependencies updated and regularly check for security vulnerabilities.</li> <li>Code Reviews: All security-sensitive code should undergo thorough code review.</li> </ol>"},{"location":"development/security/#cryptographic-practices","title":"Cryptographic Practices","text":"<ol> <li>Use Established Libraries: Use established cryptographic libraries rather than implementing custom cryptographic functions.</li> <li>Follow Standards: Follow cryptographic standards and best practices.</li> <li>Key Management: Implement proper key management practices.</li> <li>Avoid Hardcoding: Never hardcode secrets or keys in the source code.</li> </ol>"},{"location":"development/security/#authentication-and-authorization","title":"Authentication and Authorization","text":"<ol> <li>Separation of Concerns: Keep authentication and authorization logic separate.</li> <li>Principle of Least Privilege: Implement access controls based on the principle of least privilege.</li> <li>Session Management: Implement secure session management practices.</li> <li>Error Messages: Use generic error messages that don't reveal sensitive information.</li> </ol>"},{"location":"development/security/#security-testing","title":"Security Testing","text":"<p>The Evrmore Authentication system undergoes regular security testing:</p> <ol> <li>Automated Security Testing: Automated security tests are run as part of the CI/CD pipeline.</li> <li>Dependency Scanning: Regular scanning for vulnerabilities in dependencies.</li> <li>Code Scanning: Static code analysis to identify potential security issues.</li> <li>Penetration Testing: Periodic penetration testing by security professionals.</li> </ol>"},{"location":"development/security/#security-compliance","title":"Security Compliance","text":"<p>The Evrmore Authentication system is designed to help applications comply with various security standards and regulations:</p> <ol> <li>OWASP Top 10: Addresses the OWASP Top 10 web application security risks.</li> <li>OAuth 2.0 Security Best Practices: Follows the OAuth 2.0 Security Best Current Practice.</li> <li>GDPR Considerations: Designed with privacy and data protection in mind.</li> </ol>"},{"location":"development/security/#security-faqs","title":"Security FAQs","text":""},{"location":"development/security/#how-are-user-credentials-stored","title":"How are user credentials stored?","text":"<p>The Evrmore Authentication system does not store user passwords. It uses Evrmore wallet signatures for authentication, which means users prove their identity by signing messages with their private keys, which are never transmitted to the server.</p>"},{"location":"development/security/#how-are-tokens-secured","title":"How are tokens secured?","text":"<p>Tokens are secured using industry-standard JWT practices, including: - Digital signatures to prevent tampering - Expiration times to limit the window of opportunity for token theft - The ability to invalidate tokens if compromised</p>"},{"location":"development/security/#is-my-data-encrypted","title":"Is my data encrypted?","text":"<p>Sensitive data in the database is encrypted. All communication with the authentication server should be over HTTPS to ensure data in transit is encrypted.</p>"},{"location":"development/security/#how-do-i-secure-my-client-application","title":"How do I secure my client application?","text":"<p>For client applications: - Store tokens securely (e.g., in HttpOnly cookies for web applications) - Implement proper CSRF protection - Use HTTPS for all communication - Validate all data received from the authentication server - Implement proper error handling</p>"},{"location":"development/security/#what-should-i-do-if-i-suspect-a-security-breach","title":"What should I do if I suspect a security breach?","text":"<p>If you suspect a security breach: 1. Invalidate all potentially affected tokens 2. Rotate any compromised secrets 3. Contact the maintainers at dev@manticore.technology 4. Investigate the breach and take appropriate remediation steps</p>"},{"location":"development/security/#security-resources","title":"Security Resources","text":"<ul> <li>OWASP Authentication Cheat Sheet</li> <li>OAuth 2.0 Security Best Current Practice</li> <li>JWT Best Practices</li> <li>NIST Digital Identity Guidelines</li> </ul>"},{"location":"development/security/#acknowledgments","title":"Acknowledgments","text":"<p>We would like to thank all security researchers and contributors who have helped improve the security of the Evrmore Authentication system. </p>"},{"location":"development/testing/","title":"Testing Guide","text":"<p>This guide covers the testing approach for the Evrmore Authentication system, including unit tests, integration tests, and how to run and extend the test suite.</p>"},{"location":"development/testing/#testing-philosophy","title":"Testing Philosophy","text":"<p>The Evrmore Authentication system follows these testing principles:</p> <ol> <li>Test-Driven Development: Critical components are developed using TDD where possible.</li> <li>Comprehensive Coverage: Aim for high test coverage, especially for security-critical components.</li> <li>Isolation: Unit tests should be isolated and not depend on external services.</li> <li>Realistic Scenarios: Integration tests should simulate real-world usage patterns.</li> </ol>"},{"location":"development/testing/#test-structure","title":"Test Structure","text":"<p>The tests are organized in the following structure:</p> <pre><code>evrmore_authentication/tests/\n\u251c\u2500\u2500 unit/                 # Unit tests\n\u2502   \u251c\u2500\u2500 test_auth.py      # Tests for core authentication functionality\n\u2502   \u251c\u2500\u2500 test_crypto.py    # Tests for cryptographic functions\n\u2502   \u251c\u2500\u2500 test_models.py    # Tests for data models\n\u2502   \u2514\u2500\u2500 test_utils.py     # Tests for utility functions\n\u251c\u2500\u2500 integration/          # Integration tests\n\u2502   \u251c\u2500\u2500 test_api.py       # Tests for API endpoints\n\u2502   \u2514\u2500\u2500 test_oauth.py     # Tests for OAuth functionality\n\u2514\u2500\u2500 conftest.py           # Pytest fixtures and configuration\n</code></pre>"},{"location":"development/testing/#running-tests","title":"Running Tests","text":""},{"location":"development/testing/#prerequisites","title":"Prerequisites","text":"<p>Before running tests, ensure you have the required dependencies:</p> <pre><code>pip3 install pytest pytest-cov pytest-mock\n</code></pre>"},{"location":"development/testing/#running-all-tests","title":"Running All Tests","text":"<p>To run all tests:</p> <pre><code>python3 -m pytest\n</code></pre>"},{"location":"development/testing/#running-specific-test-categories","title":"Running Specific Test Categories","text":"<p>To run only unit tests:</p> <pre><code>python3 -m pytest evrmore_authentication/tests/unit/\n</code></pre> <p>To run only integration tests:</p> <pre><code>python3 -m pytest evrmore_authentication/tests/integration/\n</code></pre>"},{"location":"development/testing/#running-a-specific-test-file","title":"Running a Specific Test File","text":"<p>To run tests from a specific file:</p> <pre><code>python3 -m pytest evrmore_authentication/tests/unit/test_auth.py\n</code></pre>"},{"location":"development/testing/#running-a-specific-test","title":"Running a Specific Test","text":"<p>To run a specific test function:</p> <pre><code>python3 -m pytest evrmore_authentication/tests/unit/test_auth.py::test_generate_challenge\n</code></pre>"},{"location":"development/testing/#test-coverage","title":"Test Coverage","text":"<p>To generate a test coverage report:</p> <pre><code>python3 -m pytest --cov=evrmore_authentication\n</code></pre> <p>For a detailed HTML coverage report:</p> <pre><code>python3 -m pytest --cov=evrmore_authentication --cov-report=html\n</code></pre> <p>This will create a <code>htmlcov</code> directory with an HTML report that you can open in your browser.</p>"},{"location":"development/testing/#writing-tests","title":"Writing Tests","text":""},{"location":"development/testing/#unit-tests","title":"Unit Tests","text":"<p>Unit tests should focus on testing individual functions or methods in isolation. Use mocks to avoid dependencies on external services or other components.</p> <p>Example of a unit test:</p> <pre><code>def test_verify_signature(mocker):\n    # Arrange\n    mock_verify = mocker.patch('evrmore_authentication.crypto.verify_message', return_value=True)\n    auth = EvrmoreAuth()\n    address = \"EXaMPLeEvRMoReAddResS\"\n    message = \"Test message\"\n    signature = \"TestSignature\"\n\n    # Act\n    result = auth.verify_signature(address, message, signature)\n\n    # Assert\n    assert result is True\n    mock_verify.assert_called_once_with(address, message, signature)\n</code></pre>"},{"location":"development/testing/#integration-tests","title":"Integration Tests","text":"<p>Integration tests should test the interaction between multiple components or the system as a whole. These tests may require more setup but provide confidence that the system works correctly in real-world scenarios.</p> <p>Example of an integration test:</p> <pre><code>def test_authentication_flow():\n    # Arrange\n    auth = EvrmoreAuth()\n    address, private_key = create_wallet()\n\n    # Act\n    # 1. Generate a challenge\n    challenge = auth.generate_challenge(address)\n\n    # 2. Sign the challenge\n    signature = sign_message(private_key, challenge)\n\n    # 3. Authenticate with the signature\n    session = auth.authenticate(address, challenge, signature)\n\n    # Assert\n    assert session is not None\n    assert session.user_id is not None\n    assert session.evrmore_address == address\n    assert session.token is not None\n\n    # 4. Validate the token\n    token_data = auth.validate_token(session.token)\n    assert token_data is not None\n    assert token_data.get('sub') == session.user_id\n    assert token_data.get('evr_address') == address\n</code></pre>"},{"location":"development/testing/#test-fixtures","title":"Test Fixtures","text":"<p>Pytest fixtures are used to set up test dependencies and can be defined in <code>conftest.py</code> or in individual test files.</p> <p>Example of fixtures in <code>conftest.py</code>:</p> <pre><code>import pytest\nfrom evrmore_authentication import EvrmoreAuth\nfrom evrmore_authentication.crypto import create_wallet\n\n@pytest.fixture\ndef auth():\n    \"\"\"Return an initialized EvrmoreAuth instance.\"\"\"\n    return EvrmoreAuth(jwt_secret=\"test-secret\", debug=True)\n\n@pytest.fixture\ndef test_wallet():\n    \"\"\"Create a test wallet for testing.\"\"\"\n    address, private_key = create_wallet()\n    return {\"address\": address, \"private_key\": private_key}\n\n@pytest.fixture\ndef authenticated_user(auth, test_wallet):\n    \"\"\"Return an authenticated user session.\"\"\"\n    address = test_wallet[\"address\"]\n    private_key = test_wallet[\"private_key\"]\n\n    # Generate a challenge\n    challenge = auth.generate_challenge(address)\n\n    # Sign the challenge\n    signature = sign_message(private_key, challenge)\n\n    # Authenticate\n    session = auth.authenticate(address, challenge, signature)\n\n    return {\n        \"session\": session,\n        \"address\": address,\n        \"challenge\": challenge,\n        \"signature\": signature\n    }\n</code></pre>"},{"location":"development/testing/#mocking","title":"Mocking","text":"<p>The <code>pytest-mock</code> plugin provides a <code>mocker</code> fixture that can be used to create mock objects and patch functions.</p> <p>Example of mocking:</p> <pre><code>def test_get_user_by_token(mocker):\n    # Arrange\n    mock_validate = mocker.patch('evrmore_authentication.auth.EvrmoreAuth.validate_token')\n    mock_validate.return_value = {\"sub\": \"test-user-id\", \"evr_address\": \"test-address\"}\n\n    mock_get_user = mocker.patch('evrmore_authentication.models.User.get_by_id')\n    mock_user = mocker.MagicMock()\n    mock_user.id = \"test-user-id\"\n    mock_get_user.return_value = mock_user\n\n    auth = EvrmoreAuth()\n\n    # Act\n    user = auth.get_user_by_token(\"test-token\")\n\n    # Assert\n    assert user is mock_user\n    mock_validate.assert_called_once_with(\"test-token\")\n    mock_get_user.assert_called_once_with(\"test-user-id\")\n</code></pre>"},{"location":"development/testing/#testing-api-endpoints","title":"Testing API Endpoints","text":"<p>API endpoints can be tested using FastAPI's <code>TestClient</code>.</p> <p>Example of testing an API endpoint:</p> <pre><code>from fastapi.testclient import TestClient\nfrom evrmore_authentication.api import app\n\nclient = TestClient(app)\n\ndef test_generate_challenge_endpoint():\n    # Arrange\n    test_address = \"EXaMPLeEvRMoReAddResS\"\n\n    # Act\n    response = client.post(\n        \"/auth/challenge\",\n        json={\"evrmore_address\": test_address}\n    )\n\n    # Assert\n    assert response.status_code == 200\n    data = response.json()\n    assert \"challenge\" in data\n    assert data[\"status\"] == \"success\"\n</code></pre>"},{"location":"development/testing/#testing-oauth-functionality","title":"Testing OAuth Functionality","text":"<p>OAuth functionality requires more complex setup and interaction between client and server.</p> <p>Example of testing OAuth authorization:</p> <pre><code>def test_oauth_authorization_flow(mocker):\n    # Mock the authentication\n    mock_auth = mocker.patch('evrmore_authentication.oauth.authenticate_user')\n    mock_auth.return_value = {\"user_id\": \"test-user-id\", \"evrmore_address\": \"test-address\"}\n\n    # Mock the client validation\n    mock_client = mocker.patch('evrmore_authentication.oauth.get_client_by_id')\n    mock_client.return_value = {\n        \"id\": \"test-client-id\",\n        \"name\": \"Test Client\",\n        \"redirect_uris\": [\"http://localhost/callback\"],\n        \"scopes\": [\"profile\"]\n    }\n\n    # Create a test client\n    client = TestClient(app)\n\n    # Act - Initiate the authorization flow\n    response = client.get(\n        \"/oauth/auth\",\n        params={\n            \"client_id\": \"test-client-id\",\n            \"redirect_uri\": \"http://localhost/callback\",\n            \"response_type\": \"code\",\n            \"scope\": \"profile\",\n            \"state\": \"test-state\"\n        }\n    )\n\n    # Assert - Should redirect to login page\n    assert response.status_code == 302\n    assert \"/oauth/login\" in response.headers[\"location\"]\n\n    # Act - Simulate successful login and authorization\n    response = client.post(\n        \"/oauth/login\",\n        json={\n            \"evrmore_address\": \"test-address\",\n            \"challenge\": \"test-challenge\",\n            \"signature\": \"test-signature\",\n            \"client_id\": \"test-client-id\",\n            \"redirect_uri\": \"http://localhost/callback\",\n            \"scope\": \"profile\",\n            \"state\": \"test-state\"\n        }\n    )\n\n    # Assert - Should redirect to the client with an authorization code\n    assert response.status_code == 302\n    redirect_uri = response.headers[\"location\"]\n    assert \"http://localhost/callback\" in redirect_uri\n    assert \"code=\" in redirect_uri\n    assert \"state=test-state\" in redirect_uri\n</code></pre>"},{"location":"development/testing/#continuous-integration","title":"Continuous Integration","text":"<p>Tests are automatically run in the CI pipeline on every push and pull request. The CI configuration is defined in the <code>.github/workflows/tests.yml</code> file.</p>"},{"location":"development/testing/#test-environment","title":"Test Environment","text":"<p>Tests use an in-memory SQLite database by default to avoid affecting any production data. The database is created fresh for each test run and destroyed afterward.</p> <p>To configure the test environment, you can set environment variables or modify the <code>conftest.py</code> file.</p>"},{"location":"development/testing/#troubleshooting-tests","title":"Troubleshooting Tests","text":""},{"location":"development/testing/#common-issues","title":"Common Issues","text":"<ol> <li>Database Errors: Ensure the test database is properly configured and accessible.</li> <li>Import Errors: Check that all required dependencies are installed.</li> <li>Mock Issues: Verify that mocks are correctly set up and returning the expected values.</li> <li>Fixture Errors: Ensure fixtures are correctly defined and dependencies are resolved.</li> </ol>"},{"location":"development/testing/#debugging-tests","title":"Debugging Tests","text":"<p>To run tests with more verbose output:</p> <pre><code>python3 -m pytest -v\n</code></pre> <p>To enable print statements during tests:</p> <pre><code>python3 -m pytest -v --capture=no\n</code></pre> <p>To debug a specific test with a debugger:</p> <pre><code>python3 -m pytest --pdb evrmore_authentication/tests/unit/test_auth.py::test_generate_challenge\n</code></pre>"},{"location":"development/testing/#best-practices","title":"Best Practices","text":"<ol> <li>Keep Tests Fast: Tests should run quickly to encourage frequent testing.</li> <li>Independent Tests: Tests should not depend on each other or run in a specific order.</li> <li>Clear Assertions: Make assertions clear and specific to what is being tested.</li> <li>Test Edge Cases: Include tests for edge cases and error conditions.</li> <li>Maintain Tests: Update tests when the code changes to prevent test debt.</li> </ol>"},{"location":"development/testing/#contributing-tests","title":"Contributing Tests","text":"<p>When contributing new features or bug fixes, please include appropriate tests. Follow these guidelines:</p> <ol> <li>Write tests for new functionality before implementing it (TDD).</li> <li>Add regression tests for bug fixes to prevent the bug from recurring.</li> <li>Follow the existing test structure and naming conventions.</li> <li>Ensure all tests pass before submitting a pull request.</li> </ol>"},{"location":"development/testing/#additional-resources","title":"Additional Resources","text":"<ul> <li>Pytest Documentation</li> <li>FastAPI Testing Documentation</li> <li>Python Mock Object Library </li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>This section provides practical examples of using Evrmore Authentication in different scenarios.</p>"},{"location":"examples/#basic-authentication-example","title":"Basic Authentication Example","text":"<pre><code>from evrmore_authentication import EvrmoreAuth\nfrom evrmore_rpc import EvrmoreClient\n\n# Initialize the authentication system\nclient = EvrmoreClient()\nauth = EvrmoreAuth(client)\n\n# Generate a challenge for a user's Evrmore address\nevrmore_address = \"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\"\nchallenge = auth.generate_challenge(evrmore_address)\nprint(f\"Challenge: {challenge}\")\n\n# In a real application, the user would sign this challenge with their wallet\n# For testing, we can use the Evrmore client to sign the message\nsignature = client.signmessage(evrmore_address, challenge)\nprint(f\"Signature: {signature}\")\n\n# Authenticate the user with the signed challenge\nsession = auth.authenticate(evrmore_address, challenge, signature)\nprint(f\"Token: {session.token}\")\nprint(f\"User ID: {session.user_id}\")\nprint(f\"Expires at: {session.expires_at}\")\n\n# Validate the token\npayload = auth.validate_token(session.token)\nprint(f\"Token payload: {payload}\")\n\n# Get the user by token\nuser = auth.get_user_by_token(session.token)\nprint(f\"User: {user.evrmore_address}\")\n\n# Invalidate the token (logout)\nauth.invalidate_token(session.token)\nprint(\"Token invalidated\")\n</code></pre>"},{"location":"examples/#fastapi-integration-example","title":"FastAPI Integration Example","text":"<pre><code>from fastapi import FastAPI, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom evrmore_authentication import EvrmoreAuth, get_current_user\nfrom evrmore_authentication.exceptions import InvalidTokenError, UserNotFoundError\n\napp = FastAPI(title=\"Evrmore Auth API\")\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\nauth = EvrmoreAuth()\n\n@app.post(\"/challenge\")\nasync def generate_challenge(evrmore_address: str):\n    \"\"\"Generate a challenge for a user to sign with their Evrmore wallet.\"\"\"\n    challenge = auth.generate_challenge(evrmore_address)\n    return {\"challenge\": challenge}\n\n@app.post(\"/authenticate\")\nasync def authenticate(evrmore_address: str, challenge: str, signature: str):\n    \"\"\"Authenticate a user with their signed challenge.\"\"\"\n    try:\n        session = auth.authenticate(evrmore_address, challenge, signature)\n        return {\n            \"token\": session.token,\n            \"user_id\": session.user_id,\n            \"evrmore_address\": session.evrmore_address,\n            \"expires_at\": session.expires_at\n        }\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=str(e),\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n@app.get(\"/me\")\nasync def get_current_user_info(current_user = Depends(get_current_user)):\n    \"\"\"Get information about the currently authenticated user.\"\"\"\n    return {\n        \"id\": str(current_user.id),\n        \"evrmore_address\": current_user.evrmore_address,\n        \"username\": current_user.username,\n        \"email\": current_user.email,\n        \"is_active\": current_user.is_active,\n        \"created_at\": current_user.created_at,\n        \"last_login\": current_user.last_login\n    }\n\n@app.post(\"/logout\")\nasync def logout(token: str):\n    \"\"\"Invalidate a JWT token (logout).\"\"\"\n    try:\n        auth.invalidate_token(token)\n        return {\"success\": True}\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=str(e)\n        )\n</code></pre>"},{"location":"examples/#web-application-example","title":"Web Application Example","text":"<p>See the complete web application example in the examples/web_auth_demo directory. </p>"},{"location":"examples/basic-demo/","title":"Basic Authentication Demo","text":"<p>This guide demonstrates a simple implementation of Evrmore Authentication in a basic Python application. It will walk you through implementing wallet-based authentication with minimal dependencies.</p>"},{"location":"examples/basic-demo/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+</li> <li><code>evrmore-authentication</code> package installed</li> <li>Basic understanding of Python and Evrmore wallets</li> </ul>"},{"location":"examples/basic-demo/#installation","title":"Installation","text":"<pre><code>pip3 install evrmore-authentication\n</code></pre>"},{"location":"examples/basic-demo/#simple-authentication-flow","title":"Simple Authentication Flow","text":""},{"location":"examples/basic-demo/#1-initialize-the-authentication-system","title":"1. Initialize the Authentication System","text":"<p>Create a simple script that initializes the Evrmore Authentication system:</p> <pre><code># auth_demo.py\nfrom evrmore_authentication import EvrmoreAuth\n\n# Initialize the authentication system\nauth = EvrmoreAuth(\n    jwt_secret=\"your-secret-key\",\n    debug=True  # Set to False in production\n)\n\nprint(\"Evrmore Authentication system initialized\")\n</code></pre>"},{"location":"examples/basic-demo/#2-generate-a-challenge","title":"2. Generate a Challenge","text":"<p>Add code to generate a challenge for a user to sign:</p> <pre><code># Generate a challenge for an Evrmore address\nevrmore_address = \"EXaMPLeEvRMoReAddResS\"  # Replace with a real address\nchallenge = auth.generate_challenge(evrmore_address)\n\nprint(f\"Challenge generated for {evrmore_address}:\")\nprint(challenge)\n</code></pre>"},{"location":"examples/basic-demo/#3-sign-the-challenge-with-a-wallet","title":"3. Sign the Challenge with a Wallet","text":"<p>In a real application, the user would sign this challenge with their Evrmore wallet. For demonstration purposes, we'll use the development utilities to create a wallet and sign the challenge:</p> <pre><code># For demonstration purposes only - in a real app, user would sign with their wallet\nfrom evrmore_authentication.crypto import create_wallet, sign_message\n\n# Create a test wallet (in a real app, the user would use their own wallet)\naddress, private_key_wif = create_wallet()\nprint(f\"Test wallet created: {address}\")\n\n# Sign the challenge\nsignature = sign_message(private_key_wif, challenge)\nprint(f\"Signature: {signature}\")\n</code></pre>"},{"location":"examples/basic-demo/#4-authenticate-with-the-signature","title":"4. Authenticate with the Signature","text":"<p>Now authenticate the user with the signature:</p> <pre><code># Authenticate the user\ntry:\n    session = auth.authenticate(\n        evrmore_address=address,\n        challenge=challenge,\n        signature=signature\n    )\n    print(\"Authentication successful!\")\n    print(f\"User ID: {session.user_id}\")\n    print(f\"Token: {session.token}\")\n    print(f\"Expires at: {session.expires_at}\")\nexcept Exception as e:\n    print(f\"Authentication failed: {str(e)}\")\n</code></pre>"},{"location":"examples/basic-demo/#5-validate-the-token","title":"5. Validate the Token","text":"<p>Add code to validate the token:</p> <pre><code># Validate the token\ntoken = session.token\ntoken_data = auth.validate_token(token)\n\nif token_data:\n    print(\"Token is valid!\")\n    print(f\"User ID: {token_data.get('sub')}\")\n    print(f\"Evrmore Address: {token_data.get('evr_address')}\")\nelse:\n    print(\"Token is invalid!\")\n</code></pre>"},{"location":"examples/basic-demo/#6-invalidate-the-token-logout","title":"6. Invalidate the Token (Logout)","text":"<p>Finally, add code to invalidate the token (logout):</p> <pre><code># Invalidate the token (logout)\nsuccess = auth.invalidate_token(token)\nif success:\n    print(\"User logged out successfully\")\nelse:\n    print(\"Failed to log out\")\n\n# Try to validate the token again\ntoken_data = auth.validate_token(token)\nif token_data:\n    print(\"Token is still valid (unexpected)\")\nelse:\n    print(\"Token has been invalidated\")\n</code></pre>"},{"location":"examples/basic-demo/#complete-example","title":"Complete Example","text":"<p>Here's the complete script:</p> <pre><code># auth_demo.py\nfrom evrmore_authentication import EvrmoreAuth\nfrom evrmore_authentication.crypto import create_wallet, sign_message\n\n# Initialize the authentication system\nauth = EvrmoreAuth(\n    jwt_secret=\"your-secret-key\",\n    debug=True  # Set to False in production\n)\n\nprint(\"Evrmore Authentication system initialized\")\n\n# Create a test wallet (in a real app, the user would use their own wallet)\naddress, private_key_wif = create_wallet()\nprint(f\"Test wallet created: {address}\")\n\n# Generate a challenge for the address\nchallenge = auth.generate_challenge(address)\nprint(f\"Challenge generated: {challenge}\")\n\n# Sign the challenge\nsignature = sign_message(private_key_wif, challenge)\nprint(f\"Signature: {signature}\")\n\n# Authenticate the user\ntry:\n    session = auth.authenticate(\n        evrmore_address=address,\n        challenge=challenge,\n        signature=signature\n    )\n    print(\"Authentication successful!\")\n    print(f\"User ID: {session.user_id}\")\n    print(f\"Token: {session.token}\")\n    print(f\"Expires at: {session.expires_at}\")\nexcept Exception as e:\n    print(f\"Authentication failed: {str(e)}\")\n    exit(1)\n\n# Validate the token\ntoken = session.token\ntoken_data = auth.validate_token(token)\n\nif token_data:\n    print(\"Token is valid!\")\n    print(f\"User ID: {token_data.get('sub')}\")\n    print(f\"Evrmore Address: {token_data.get('evr_address')}\")\nelse:\n    print(\"Token is invalid!\")\n\n# Invalidate the token (logout)\nsuccess = auth.invalidate_token(token)\nif success:\n    print(\"User logged out successfully\")\nelse:\n    print(\"Failed to log out\")\n\n# Try to validate the token again\ntoken_data = auth.validate_token(token)\nif token_data:\n    print(\"Token is still valid (unexpected)\")\nelse:\n    print(\"Token has been invalidated\")\n</code></pre>"},{"location":"examples/basic-demo/#running-the-demo","title":"Running the Demo","text":"<p>Save the script and run it:</p> <pre><code>python3 auth_demo.py\n</code></pre> <p>You should see output similar to this:</p> <pre><code>Evrmore Authentication system initialized\nTest wallet created: EXaMPLeEvRMoReAddResS\nChallenge generated: Sign this message to authenticate: a8f7e9d1c2b3...\nSignature: H9LJFkR+a0MFm1jSvmoBZ1wQobuSGP...\nAuthentication successful!\nUser ID: 123e4567-e89b-12d3-a456-426614174000\nToken: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\nExpires at: 2023-03-16 15:30:45.123456\nToken is valid!\nUser ID: 123e4567-e89b-12d3-a456-426614174000\nEvrmore Address: EXaMPLeEvRMoReAddResS\nUser logged out successfully\nToken has been invalidated\n</code></pre>"},{"location":"examples/basic-demo/#next-steps","title":"Next Steps","text":"<p>After mastering this basic implementation, you can:</p> <ol> <li>Integrate the authentication system into a web application</li> <li>Add user profile management</li> <li>Implement more advanced features like token refresh</li> <li>Check out the FastAPI integration example for a more complete implementation</li> </ol> <p>See the FastAPI integration example and OAuth client example for more advanced implementations. </p>"},{"location":"examples/fastapi-integration/","title":"FastAPI Integration Guide","text":"<p>This guide demonstrates how to integrate Evrmore Authentication into a FastAPI application. FastAPI is a modern, fast web framework for building APIs with Python that's well-suited for projects requiring blockchain authentication.</p>"},{"location":"examples/fastapi-integration/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+</li> <li>FastAPI and its dependencies (<code>pip3 install fastapi uvicorn</code>)</li> <li><code>evrmore-authentication</code> package installed</li> <li>Basic understanding of FastAPI and asynchronous Python</li> </ul>"},{"location":"examples/fastapi-integration/#project-setup","title":"Project Setup","text":"<p>Create a new directory for your FastAPI project:</p> <pre><code>mkdir fastapi-evrmore-auth\ncd fastapi-evrmore-auth\n</code></pre> <p>Create a virtual environment and install the required packages:</p> <pre><code>python3 -m venv venv\nsource venv/bin/activate\npip3 install fastapi uvicorn evrmore-authentication python-multipart\n</code></pre>"},{"location":"examples/fastapi-integration/#basic-fastapi-integration","title":"Basic FastAPI Integration","text":""},{"location":"examples/fastapi-integration/#1-create-the-main-application","title":"1. Create the Main Application","text":"<p>Create a file named <code>main.py</code> with the following content:</p> <pre><code>from fastapi import FastAPI, Depends, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom fastapi.middleware.cors import CORSMiddleware\nimport uvicorn\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nfrom evrmore_authentication import EvrmoreAuth\n\n# Initialize FastAPI app\napp = FastAPI(title=\"Evrmore Auth API\", description=\"API with Evrmore Authentication\")\n\n# Add CORS middleware to allow frontend integration\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],  # In production, specify your frontend domains\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Initialize Evrmore Authentication\nauth = EvrmoreAuth(\n    jwt_secret=\"your-secret-key\",  # Use a secure secret in production\n    debug=True  # Set to False in production\n)\n\n# Create a Pydantic model for authentication requests\nclass AuthRequest(BaseModel):\n    evrmore_address: str\n    challenge: Optional[str] = None\n    signature: Optional[str] = None\n\n# Create a Pydantic model for token validation\nclass TokenRequest(BaseModel):\n    token: str\n\n@app.get(\"/\")\nasync def read_root():\n    return {\"message\": \"Welcome to Evrmore Authentication API\"}\n</code></pre>"},{"location":"examples/fastapi-integration/#2-add-challenge-generation-endpoint","title":"2. Add Challenge Generation Endpoint","text":"<p>Add a challenge generation endpoint to the <code>main.py</code> file:</p> <pre><code>@app.post(\"/generate-challenge\")\nasync def generate_challenge(request: AuthRequest):\n    \"\"\"Generate a challenge for the provided Evrmore address\"\"\"\n    try:\n        challenge = auth.generate_challenge(request.evrmore_address)\n        return {\"status\": \"success\", \"challenge\": challenge}\n    except Exception as e:\n        return JSONResponse(\n            status_code=400,\n            content={\"status\": \"error\", \"message\": str(e)}\n        )\n</code></pre>"},{"location":"examples/fastapi-integration/#3-add-authentication-endpoint","title":"3. Add Authentication Endpoint","text":"<p>Add an authentication endpoint to the <code>main.py</code> file:</p> <pre><code>@app.post(\"/authenticate\")\nasync def authenticate(request: AuthRequest):\n    \"\"\"Authenticate a user with their address, challenge, and signature\"\"\"\n    try:\n        session = auth.authenticate(\n            evrmore_address=request.evrmore_address,\n            challenge=request.challenge,\n            signature=request.signature\n        )\n\n        return {\n            \"status\": \"success\",\n            \"user_id\": session.user_id,\n            \"token\": session.token,\n            \"expires_at\": str(session.expires_at)\n        }\n    except Exception as e:\n        return JSONResponse(\n            status_code=401,\n            content={\"status\": \"error\", \"message\": str(e)}\n        )\n</code></pre>"},{"location":"examples/fastapi-integration/#4-add-token-validation-endpoints","title":"4. Add Token Validation Endpoints","text":"<p>Add token validation endpoints to the <code>main.py</code> file:</p> <pre><code>@app.post(\"/validate-token\")\nasync def validate_token(request: TokenRequest):\n    \"\"\"Validate a JWT token\"\"\"\n    token_data = auth.validate_token(request.token)\n\n    if token_data:\n        return {\n            \"status\": \"success\",\n            \"user_id\": token_data.get(\"sub\"),\n            \"evrmore_address\": token_data.get(\"evr_address\")\n        }\n    else:\n        return JSONResponse(\n            status_code=401,\n            content={\"status\": \"error\", \"message\": \"Invalid token\"}\n        )\n\n@app.post(\"/logout\")\nasync def logout(request: TokenRequest):\n    \"\"\"Invalidate a JWT token (logout)\"\"\"\n    success = auth.invalidate_token(request.token)\n\n    if success:\n        return {\"status\": \"success\", \"message\": \"Logged out successfully\"}\n    else:\n        return JSONResponse(\n            status_code=400,\n            content={\"status\": \"error\", \"message\": \"Failed to log out\"}\n        )\n</code></pre>"},{"location":"examples/fastapi-integration/#5-add-protected-routes-with-authentication-dependency","title":"5. Add Protected Routes with Authentication Dependency","text":"<p>Create authentication dependencies and protected routes:</p> <pre><code># Authentication dependency\nasync def get_current_user(request: Request):\n    # Get token from Authorization header\n    auth_header = request.headers.get(\"Authorization\")\n    if not auth_header or not auth_header.startswith(\"Bearer \"):\n        raise HTTPException(status_code=401, detail=\"Missing or invalid token\")\n\n    token = auth_header.replace(\"Bearer \", \"\")\n    token_data = auth.validate_token(token)\n\n    if not token_data:\n        raise HTTPException(status_code=401, detail=\"Invalid or expired token\")\n\n    # Get the user by ID\n    user_id = token_data.get(\"sub\")\n    user = auth.get_user_by_id(user_id)\n\n    if not user:\n        raise HTTPException(status_code=401, detail=\"User not found\")\n\n    return user\n\n# Protected route example\n@app.get(\"/protected\")\nasync def protected_route(user = Depends(get_current_user)):\n    \"\"\"This endpoint requires authentication\"\"\"\n    return {\n        \"status\": \"success\",\n        \"message\": \"You have access to this protected resource\",\n        \"user_id\": user.id,\n        \"evrmore_address\": user.evrmore_address\n    }\n</code></pre>"},{"location":"examples/fastapi-integration/#6-run-the-application","title":"6. Run the Application","text":"<p>Add a main block to run the application:</p> <pre><code>if __name__ == \"__main__\":\n    uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=8000, reload=True)\n</code></pre>"},{"location":"examples/fastapi-integration/#complete-example","title":"Complete Example","text":"<p>The complete <code>main.py</code> file should look like this:</p> <pre><code>from fastapi import FastAPI, Depends, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom fastapi.middleware.cors import CORSMiddleware\nimport uvicorn\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nfrom evrmore_authentication import EvrmoreAuth\n\n# Initialize FastAPI app\napp = FastAPI(title=\"Evrmore Auth API\", description=\"API with Evrmore Authentication\")\n\n# Add CORS middleware to allow frontend integration\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],  # In production, specify your frontend domains\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Initialize Evrmore Authentication\nauth = EvrmoreAuth(\n    jwt_secret=\"your-secret-key\",  # Use a secure secret in production\n    debug=True  # Set to False in production\n)\n\n# Create a Pydantic model for authentication requests\nclass AuthRequest(BaseModel):\n    evrmore_address: str\n    challenge: Optional[str] = None\n    signature: Optional[str] = None\n\n# Create a Pydantic model for token validation\nclass TokenRequest(BaseModel):\n    token: str\n\n@app.get(\"/\")\nasync def read_root():\n    return {\"message\": \"Welcome to Evrmore Authentication API\"}\n\n@app.post(\"/generate-challenge\")\nasync def generate_challenge(request: AuthRequest):\n    \"\"\"Generate a challenge for the provided Evrmore address\"\"\"\n    try:\n        challenge = auth.generate_challenge(request.evrmore_address)\n        return {\"status\": \"success\", \"challenge\": challenge}\n    except Exception as e:\n        return JSONResponse(\n            status_code=400,\n            content={\"status\": \"error\", \"message\": str(e)}\n        )\n\n@app.post(\"/authenticate\")\nasync def authenticate(request: AuthRequest):\n    \"\"\"Authenticate a user with their address, challenge, and signature\"\"\"\n    try:\n        session = auth.authenticate(\n            evrmore_address=request.evrmore_address,\n            challenge=request.challenge,\n            signature=request.signature\n        )\n\n        return {\n            \"status\": \"success\",\n            \"user_id\": session.user_id,\n            \"token\": session.token,\n            \"expires_at\": str(session.expires_at)\n        }\n    except Exception as e:\n        return JSONResponse(\n            status_code=401,\n            content={\"status\": \"error\", \"message\": str(e)}\n        )\n\n@app.post(\"/validate-token\")\nasync def validate_token(request: TokenRequest):\n    \"\"\"Validate a JWT token\"\"\"\n    token_data = auth.validate_token(request.token)\n\n    if token_data:\n        return {\n            \"status\": \"success\",\n            \"user_id\": token_data.get(\"sub\"),\n            \"evrmore_address\": token_data.get(\"evr_address\")\n        }\n    else:\n        return JSONResponse(\n            status_code=401,\n            content={\"status\": \"error\", \"message\": \"Invalid token\"}\n        )\n\n@app.post(\"/logout\")\nasync def logout(request: TokenRequest):\n    \"\"\"Invalidate a JWT token (logout)\"\"\"\n    success = auth.invalidate_token(request.token)\n\n    if success:\n        return {\"status\": \"success\", \"message\": \"Logged out successfully\"}\n    else:\n        return JSONResponse(\n            status_code=400,\n            content={\"status\": \"error\", \"message\": \"Failed to log out\"}\n        )\n\n# Authentication dependency\nasync def get_current_user(request: Request):\n    # Get token from Authorization header\n    auth_header = request.headers.get(\"Authorization\")\n    if not auth_header or not auth_header.startswith(\"Bearer \"):\n        raise HTTPException(status_code=401, detail=\"Missing or invalid token\")\n\n    token = auth_header.replace(\"Bearer \", \"\")\n    token_data = auth.validate_token(token)\n\n    if not token_data:\n        raise HTTPException(status_code=401, detail=\"Invalid or expired token\")\n\n    # Get the user by ID\n    user_id = token_data.get(\"sub\")\n    user = auth.get_user_by_id(user_id)\n\n    if not user:\n        raise HTTPException(status_code=401, detail=\"User not found\")\n\n    return user\n\n# Protected route example\n@app.get(\"/protected\")\nasync def protected_route(user = Depends(get_current_user)):\n    \"\"\"This endpoint requires authentication\"\"\"\n    return {\n        \"status\": \"success\",\n        \"message\": \"You have access to this protected resource\",\n        \"user_id\": user.id,\n        \"evrmore_address\": user.evrmore_address\n    }\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=8000, reload=True)\n</code></pre>"},{"location":"examples/fastapi-integration/#running-the-application","title":"Running the Application","text":"<p>Run the FastAPI application:</p> <pre><code>python3 main.py\n</code></pre> <p>The API will be available at <code>http://localhost:8000</code>.</p>"},{"location":"examples/fastapi-integration/#testing-with-swagger-ui","title":"Testing with Swagger UI","text":"<p>FastAPI provides automatic interactive API documentation with Swagger UI. You can access it at <code>http://localhost:8000/docs</code>.</p> <p>Using the Swagger UI, you can:</p> <ol> <li>Try the <code>/generate-challenge</code> endpoint to get a challenge</li> <li>Use your Evrmore wallet to sign the challenge (or use the development tools for testing)</li> <li>Submit the signature to the <code>/authenticate</code> endpoint to get a token</li> <li>Use the token to access the <code>/protected</code> endpoint</li> </ol>"},{"location":"examples/fastapi-integration/#frontend-integration","title":"Frontend Integration","text":"<p>To integrate this API with a frontend application, you can use the Swagger UI as a reference for the required API calls. Here's an example of how you might implement the authentication flow in a JavaScript frontend:</p> <pre><code>// Example frontend code (JavaScript)\nasync function authenticate(evrmoreAddress) {\n  // Step 1: Generate a challenge\n  const challengeResponse = await fetch('/generate-challenge', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ evrmore_address: evrmoreAddress })\n  });\n  const challengeData = await challengeResponse.json();\n\n  if (challengeData.status !== 'success') {\n    throw new Error(challengeData.message);\n  }\n\n  // Step 2: Sign the challenge with the Evrmore wallet\n  // This depends on your wallet integration\n  const signature = await signWithWallet(evrmoreAddress, challengeData.challenge);\n\n  // Step 3: Authenticate with the signature\n  const authResponse = await fetch('/authenticate', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      evrmore_address: evrmoreAddress,\n      challenge: challengeData.challenge,\n      signature: signature\n    })\n  });\n\n  const authData = await authResponse.json();\n\n  if (authData.status !== 'success') {\n    throw new Error(authData.message);\n  }\n\n  // Store the token for future requests\n  localStorage.setItem('authToken', authData.token);\n\n  return authData;\n}\n\n// Example of how to make authenticated requests\nasync function fetchProtectedResource() {\n  const token = localStorage.getItem('authToken');\n\n  if (!token) {\n    throw new Error('Not authenticated');\n  }\n\n  const response = await fetch('/protected', {\n    headers: {\n      'Authorization': `Bearer ${token}`\n    }\n  });\n\n  return await response.json();\n}\n\n// Example of how to log out\nasync function logout() {\n  const token = localStorage.getItem('authToken');\n\n  if (!token) {\n    return { status: 'success', message: 'Already logged out' };\n  }\n\n  const response = await fetch('/logout', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ token })\n  });\n\n  const data = await response.json();\n\n  if (data.status === 'success') {\n    localStorage.removeItem('authToken');\n  }\n\n  return data;\n}\n</code></pre>"},{"location":"examples/fastapi-integration/#next-steps","title":"Next Steps","text":"<p>After implementing this basic FastAPI integration, you can:</p> <ol> <li>Add more protected routes and resources</li> <li>Implement user profiles and additional user data</li> <li>Add refresh token functionality</li> <li>Integrate with a database for persistent storage</li> <li>Add rate limiting and other security features</li> <li>Implement OAuth 2.0 for third-party applications</li> </ol> <p>For OAuth 2.0 integration, see the OAuth client example documentation. </p>"},{"location":"examples/oauth-client/","title":"OAuth Client Example","text":"<p>This guide demonstrates how to implement an OAuth 2.0 client that authenticates with the Evrmore Authentication system. The example uses FastAPI to create a simple web application that leverages Evrmore Authentication's OAuth 2.0 server for authentication.</p>"},{"location":"examples/oauth-client/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+</li> <li>FastAPI and its dependencies (<code>pip3 install fastapi uvicorn</code>)</li> <li><code>evrmore-authentication</code> package installed</li> <li><code>requests</code> and <code>python-multipart</code> packages</li> <li>Running instance of Evrmore Authentication server with OAuth enabled</li> </ul>"},{"location":"examples/oauth-client/#project-setup","title":"Project Setup","text":"<p>Create a new directory for your OAuth client project:</p> <pre><code>mkdir evrmore-oauth-client\ncd evrmore-oauth-client\n</code></pre> <p>Create a virtual environment and install the required packages:</p> <pre><code>python3 -m venv venv\nsource venv/bin/activate\npip3 install fastapi uvicorn requests python-multipart\n</code></pre>"},{"location":"examples/oauth-client/#oauth-20-client-implementation","title":"OAuth 2.0 Client Implementation","text":""},{"location":"examples/oauth-client/#1-create-the-client-configuration","title":"1. Create the Client Configuration","text":"<p>Create a file named <code>config.py</code> with the following content:</p> <pre><code># OAuth client configuration\nOAUTH_CLIENT_ID = \"your-client-id\"  # Replace with your registered client ID\nOAUTH_CLIENT_SECRET = \"your-client-secret\"  # Replace with your client secret\nOAUTH_REDIRECT_URI = \"http://localhost:8001/callback\"\n\n# Evrmore Authentication server URLs\nAUTH_SERVER_URL = \"http://localhost:8000\"  # Replace with your server URL\nAUTHORIZATION_ENDPOINT = f\"{AUTH_SERVER_URL}/oauth/auth\"\nTOKEN_ENDPOINT = f\"{AUTH_SERVER_URL}/oauth/token\"\nUSERINFO_ENDPOINT = f\"{AUTH_SERVER_URL}/oauth/userinfo\"\n</code></pre>"},{"location":"examples/oauth-client/#2-implement-the-oauth-client-application","title":"2. Implement the OAuth Client Application","text":"<p>Create a file named <code>oauth_client.py</code> with the following content:</p> <pre><code>from fastapi import FastAPI, Request, HTTPException, Depends\nfrom fastapi.responses import RedirectResponse, HTMLResponse\nfrom fastapi.templating import Jinja2Templates\nfrom fastapi.staticfiles import StaticFiles\nimport requests\nimport urllib.parse\nimport os\nimport secrets\nimport json\nfrom typing import Optional\n\nfrom config import (\n    OAUTH_CLIENT_ID,\n    OAUTH_CLIENT_SECRET,\n    OAUTH_REDIRECT_URI,\n    AUTHORIZATION_ENDPOINT,\n    TOKEN_ENDPOINT,\n    USERINFO_ENDPOINT\n)\n\napp = FastAPI(title=\"Evrmore OAuth Client\")\n\n# Create the templates and static directories if they don't exist\nos.makedirs(\"templates\", exist_ok=True)\nos.makedirs(\"static\", exist_ok=True)\n\n# Create a simple index.html template\nwith open(\"templates/index.html\", \"w\") as f:\n    f.write(\"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Evrmore OAuth Client&lt;/title&gt;\n    &lt;style&gt;\n        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }\n        .user-info { background-color: #f5f5f5; padding: 20px; border-radius: 5px; margin-top: 20px; }\n        .btn { display: inline-block; padding: 10px 20px; background-color: #4CAF50; color: white; \n               text-decoration: none; border-radius: 5px; margin-top: 20px; }\n        .logout-btn { background-color: #f44336; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Evrmore OAuth Client Example&lt;/h1&gt;\n    {% if user %}\n        &lt;div class=\"user-info\"&gt;\n            &lt;h2&gt;Authenticated User&lt;/h2&gt;\n            &lt;p&gt;&lt;strong&gt;User ID:&lt;/strong&gt; {{ user.id }}&lt;/p&gt;\n            &lt;p&gt;&lt;strong&gt;Evrmore Address:&lt;/strong&gt; {{ user.evrmore_address }}&lt;/p&gt;\n            &lt;p&gt;&lt;strong&gt;Scope:&lt;/strong&gt; {{ user.scope }}&lt;/p&gt;\n            &lt;pre&gt;{{ user_json }}&lt;/pre&gt;\n            &lt;a href=\"/logout\" class=\"btn logout-btn\"&gt;Logout&lt;/a&gt;\n        &lt;/div&gt;\n    {% else %}\n        &lt;p&gt;You are not logged in.&lt;/p&gt;\n        &lt;a href=\"/login\" class=\"btn\"&gt;Login with Evrmore&lt;/a&gt;\n    {% endif %}\n&lt;/body&gt;\n&lt;/html&gt;\n    \"\"\")\n\ntemplates = Jinja2Templates(directory=\"templates\")\napp.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\")\n\n# In-memory session storage (replace with a database in production)\nsessions = {}\n\ndef get_current_user(request: Request) -&gt; Optional[dict]:\n    \"\"\"Get the current user from the session cookie\"\"\"\n    session_id = request.cookies.get(\"session_id\")\n    if not session_id or session_id not in sessions:\n        return None\n    return sessions[session_id].get(\"user\")\n\n@app.get(\"/\", response_class=HTMLResponse)\nasync def index(request: Request, user: Optional[dict] = Depends(get_current_user)):\n    \"\"\"Main page with login/logout functionality\"\"\"\n    context = {\n        \"request\": request,\n        \"user\": user,\n        \"user_json\": json.dumps(user, indent=2) if user else None\n    }\n    return templates.TemplateResponse(\"index.html\", context)\n\n@app.get(\"/login\")\nasync def login(request: Request):\n    \"\"\"Redirect to the authorization server\"\"\"\n    # Generate a random state parameter to prevent CSRF\n    state = secrets.token_urlsafe(16)\n\n    # Store the state in the session for verification later\n    session_id = secrets.token_urlsafe(32)\n    sessions[session_id] = {\"state\": state}\n\n    # Build the authorization URL\n    params = {\n        \"client_id\": OAUTH_CLIENT_ID,\n        \"redirect_uri\": OAUTH_REDIRECT_URI,\n        \"response_type\": \"code\",\n        \"scope\": \"profile\",\n        \"state\": state\n    }\n    auth_url = f\"{AUTHORIZATION_ENDPOINT}?{urllib.parse.urlencode(params)}\"\n\n    # Redirect to the authorization server\n    response = RedirectResponse(url=auth_url)\n    response.set_cookie(key=\"session_id\", value=session_id, httponly=True)\n    return response\n\n@app.get(\"/callback\")\nasync def callback(request: Request, code: str, state: str):\n    \"\"\"Handle the OAuth callback\"\"\"\n    # Get the session\n    session_id = request.cookies.get(\"session_id\")\n    if not session_id or session_id not in sessions:\n        raise HTTPException(status_code=400, detail=\"Invalid session\")\n\n    # Verify the state parameter\n    if state != sessions[session_id].get(\"state\"):\n        raise HTTPException(status_code=400, detail=\"Invalid state parameter\")\n\n    # Exchange the authorization code for an access token\n    token_data = {\n        \"client_id\": OAUTH_CLIENT_ID,\n        \"client_secret\": OAUTH_CLIENT_SECRET,\n        \"grant_type\": \"authorization_code\",\n        \"code\": code,\n        \"redirect_uri\": OAUTH_REDIRECT_URI\n    }\n\n    token_response = requests.post(TOKEN_ENDPOINT, json=token_data)\n\n    if token_response.status_code != 200:\n        raise HTTPException(\n            status_code=400,\n            detail=f\"Failed to exchange code for token: {token_response.text}\"\n        )\n\n    token_info = token_response.json()\n    access_token = token_info.get(\"access_token\")\n\n    # Get user information with the access token\n    user_response = requests.get(\n        USERINFO_ENDPOINT,\n        headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n\n    if user_response.status_code != 200:\n        raise HTTPException(\n            status_code=400,\n            detail=f\"Failed to get user info: {user_response.text}\"\n        )\n\n    user_info = user_response.json()\n\n    # Store the user information in the session\n    sessions[session_id][\"user\"] = user_info\n    sessions[session_id][\"access_token\"] = access_token\n\n    # Redirect back to the home page\n    return RedirectResponse(url=\"/\")\n\n@app.get(\"/logout\")\nasync def logout(request: Request):\n    \"\"\"Log the user out by removing the session\"\"\"\n    session_id = request.cookies.get(\"session_id\")\n\n    if session_id and session_id in sessions:\n        # Clean up the session\n        del sessions[session_id]\n\n    # Redirect back to the home page\n    response = RedirectResponse(url=\"/\")\n    response.delete_cookie(key=\"session_id\")\n    return response\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\"oauth_client:app\", host=\"0.0.0.0\", port=8001, reload=True)\n</code></pre>"},{"location":"examples/oauth-client/#registering-your-oauth-client","title":"Registering Your OAuth Client","text":"<p>Before running the client, you need to register it with the Evrmore Authentication server. You can use the provided script or API endpoints to register your client:</p> <pre><code>python3 -m scripts.register_oauth_client \\\n    --name \"Example OAuth Client\" \\\n    --redirect-uris \"http://localhost:8001/callback\" \\\n    --scopes \"profile\" \\\n    --client-type \"confidential\"\n</code></pre> <p>This will give you a client ID and client secret that you should update in your <code>config.py</code> file.</p>"},{"location":"examples/oauth-client/#running-the-oauth-client","title":"Running the OAuth Client","text":"<p>Run the OAuth client application:</p> <pre><code>python3 oauth_client.py\n</code></pre> <p>The client will be available at <code>http://localhost:8001</code>.</p>"},{"location":"examples/oauth-client/#testing-the-oauth-flow","title":"Testing the OAuth Flow","text":"<ol> <li>Visit <code>http://localhost:8001</code> in your browser</li> <li>Click on the \"Login with Evrmore\" button</li> <li>You will be redirected to the Evrmore Authentication server</li> <li>If you're not already logged in, you'll need to authenticate with your Evrmore wallet</li> <li>After authentication, you'll be asked to authorize the client to access your profile</li> <li>Once authorized, you'll be redirected back to the client application with your user information displayed</li> </ol>"},{"location":"examples/oauth-client/#understanding-the-oauth-20-flow","title":"Understanding the OAuth 2.0 Flow","text":"<p>This example implements the Authorization Code Flow, which is the most secure OAuth 2.0 flow for web applications:</p> <ol> <li>Authorization Request: The client redirects the user to the authorization server with client ID, redirect URI, and requested scope.</li> <li>User Authentication: The user authenticates with the Evrmore Authentication server using their wallet.</li> <li>Authorization Grant: After authentication, the server asks the user to authorize the client's access to their data.</li> <li>Authorization Code: If authorized, the server redirects back to the client with an authorization code.</li> <li>Token Exchange: The client exchanges the authorization code for an access token by making a server-to-server request that includes the client secret.</li> <li>Resource Access: The client uses the access token to access protected resources (user information in this case).</li> </ol>"},{"location":"examples/oauth-client/#security-considerations","title":"Security Considerations","text":"<p>For a production application, consider these security enhancements:</p> <ol> <li>Use HTTPS: Always use HTTPS in production to protect tokens and sensitive information.</li> <li>Secure Storage: Store tokens securely, preferably in an encrypted database rather than in memory.</li> <li>PKCE Extension: Use PKCE (Proof Key for Code Exchange) for additional security, especially for public clients.</li> <li>Token Refresh: Implement token refresh functionality to obtain new access tokens without requiring re-authentication.</li> <li>Validate JWTs: Validate the JWT tokens cryptographically instead of just accepting them.</li> </ol>"},{"location":"examples/oauth-client/#advanced-features","title":"Advanced Features","text":"<p>You can enhance this basic example with:</p> <ol> <li>Token Refresh: Implement refresh token handling to maintain long-term sessions.</li> <li>Additional Scopes: Request additional scopes based on your application's needs.</li> <li>Persistent Storage: Use a database to store sessions and tokens.</li> <li>Single Sign-On: Leverage the single sign-on capabilities of OAuth 2.0.</li> <li>Custom User Interface: Improve the user interface for a better user experience.</li> </ol>"},{"location":"examples/oauth-client/#example-with-token-refresh","title":"Example with Token Refresh","text":"<p>Here's an example of how to implement token refresh:</p> <pre><code>@app.get(\"/refresh\")\nasync def refresh_token(request: Request):\n    \"\"\"Refresh the access token\"\"\"\n    session_id = request.cookies.get(\"session_id\")\n    if not session_id or session_id not in sessions:\n        return RedirectResponse(url=\"/login\")\n\n    refresh_token = sessions[session_id].get(\"refresh_token\")\n    if not refresh_token:\n        return RedirectResponse(url=\"/login\")\n\n    # Exchange the refresh token for a new access token\n    token_data = {\n        \"client_id\": OAUTH_CLIENT_ID,\n        \"client_secret\": OAUTH_CLIENT_SECRET,\n        \"grant_type\": \"refresh_token\",\n        \"refresh_token\": refresh_token\n    }\n\n    token_response = requests.post(TOKEN_ENDPOINT, json=token_data)\n\n    if token_response.status_code != 200:\n        # If refresh fails, redirect to login\n        return RedirectResponse(url=\"/login\")\n\n    token_info = token_response.json()\n    access_token = token_info.get(\"access_token\")\n    new_refresh_token = token_info.get(\"refresh_token\")\n\n    # Update the session with the new tokens\n    sessions[session_id][\"access_token\"] = access_token\n    if new_refresh_token:\n        sessions[session_id][\"refresh_token\"] = new_refresh_token\n\n    # Redirect back to the home page\n    return RedirectResponse(url=\"/\")\n</code></pre> <p>To handle a refresh token, you would need to store it when received during the initial token exchange and then use it when the access token expires.</p>"},{"location":"examples/oauth-client/#troubleshooting","title":"Troubleshooting","text":""},{"location":"examples/oauth-client/#common-issues","title":"Common Issues","text":"<ol> <li>Invalid Client ID: Make sure your client ID and secret are correctly registered with the Evrmore Authentication server.</li> <li>Redirect URI Mismatch: The redirect URI in your client registration must exactly match the one in your application.</li> <li>Expired Tokens: Access tokens expire after a set time. Use refresh tokens to get new ones.</li> <li>State Parameter Mismatch: If the state parameter doesn't match, it could indicate a CSRF attack or a session problem.</li> </ol>"},{"location":"examples/oauth-client/#debugging-tips","title":"Debugging Tips","text":"<ol> <li>Check the server logs for detailed error messages.</li> <li>Use browser developer tools to inspect the network requests.</li> <li>Add more logging to your client application to track the flow.</li> <li>Verify that your authorization and token endpoints are correct.</li> </ol>"},{"location":"examples/oauth-client/#conclusion","title":"Conclusion","text":"<p>This example demonstrates a basic OAuth 2.0 client implementation for Evrmore Authentication. You can use this as a starting point for integrating Evrmore wallet-based authentication into your web applications. </p>"},{"location":"user-guide/","title":"User Guide","text":"<p>This guide explains how to use Evrmore Authentication in your applications.</p>"},{"location":"user-guide/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Installation</li> <li>Configuration</li> <li>Basic Usage</li> <li>FastAPI Integration</li> <li>Security Considerations</li> </ul>"},{"location":"user-guide/#installation","title":"Installation","text":"<pre><code>pip3 install evrmore-authentication\n</code></pre>"},{"location":"user-guide/#configuration","title":"Configuration","text":"<p>Before using Evrmore Authentication, you need to configure both Evrmore RPC and your database connection.</p>"},{"location":"user-guide/#environment-variables","title":"Environment Variables","text":"<p>Set the following environment variables:</p> <pre><code># Evrmore RPC Configuration\nexport EVRMORE_RPC_URL=http://127.0.0.1:8819\nexport EVRMORE_RPC_USER=yourusername\nexport EVRMORE_RPC_PASSWORD=yourpassword\n\n# SQLite Configuration\nexport SQLITE_DB_PATH=./data/evrmore_auth.db\n\n# JWT Configuration\nexport JWT_SECRET=your-secure-secret-key\nexport JWT_ALGORITHM=HS256\nexport JWT_ACCESS_TOKEN_EXPIRE_MINUTES=30\nexport CHALLENGE_EXPIRE_MINUTES=10\n</code></pre>"},{"location":"user-guide/#database-initialization","title":"Database Initialization","text":"<p>Initialize the database tables:</p> <pre><code>from evrmore_authentication.db import init_db\n\n# Create all tables\ninit_db()\n</code></pre>"},{"location":"user-guide/#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/#initializing-the-authentication-system","title":"Initializing the Authentication System","text":"<pre><code>from evrmore_authentication import EvrmoreAuth\n\n# Create an authentication instance\nauth = EvrmoreAuth()\n</code></pre>"},{"location":"user-guide/#authentication-flow","title":"Authentication Flow","text":"<pre><code># 1. Generate a challenge for a user\nchallenge = auth.generate_challenge(evrmore_address=\"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\")\n\n# 2. User signs the challenge with their wallet and sends the signature\nsignature = \"user-provided-signature\"\n\n# 3. Authenticate the user and get a session\ntry:\n    session = auth.authenticate(\n        evrmore_address=\"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\",\n        challenge=challenge,\n        signature=signature\n    )\n\n    # Use the session token for subsequent requests\n    token = session.token\nexcept InvalidSignatureError:\n    # Handle invalid signature\n    pass\nexcept ChallengeExpiredError:\n    # Handle expired challenge\n    pass\n</code></pre>"},{"location":"user-guide/#validating-user-sessions","title":"Validating User Sessions","text":"<pre><code>try:\n    # Validate a JWT token\n    payload = auth.validate_token(token)\n\n    # Get the user associated with a token\n    user = auth.get_user_by_token(token)\nexcept InvalidTokenError:\n    # Handle invalid token\n    pass\n</code></pre>"},{"location":"user-guide/#fastapi-integration","title":"FastAPI Integration","text":"<p>The package provides built-in FastAPI integration:</p> <pre><code>from fastapi import FastAPI, Depends, HTTPException\nfrom evrmore_authentication import get_current_user\n\napp = FastAPI()\n\n@app.get(\"/protected-route\")\nasync def protected_route(current_user = Depends(get_current_user)):\n    return {\"message\": f\"Hello, {current_user.evrmore_address}!\"}\n</code></pre>"},{"location":"user-guide/#security-considerations","title":"Security Considerations","text":""},{"location":"user-guide/#atomicity","title":"Atomicity","text":"<p>All database operations are atomic, meaning they are executed as a single transaction that either succeeds completely or fails completely. This prevents partial updates that could lead to security issues.</p>"},{"location":"user-guide/#challenge-expiry","title":"Challenge Expiry","text":"<p>Challenges expire after a configurable time period (default: 10 minutes) to prevent replay attacks.</p>"},{"location":"user-guide/#one-time-challenges","title":"One-Time Challenges","text":"<p>Each challenge can only be used once and is marked as used after successful authentication.</p>"},{"location":"user-guide/#jwt-best-practices","title":"JWT Best Practices","text":"<ul> <li>Use a strong, unique <code>JWT_SECRET</code> in production</li> <li>Set a reasonable token expiry time</li> <li>Store tokens securely on the client side </li> </ul>"},{"location":"user-guide/authentication-flow/","title":"Authentication Flow","text":"<p>The Evrmore Authentication system implements a secure, wallet-based authentication flow that leverages the cryptographic capabilities of the Evrmore blockchain. This page explains the authentication process in detail.</p>"},{"location":"user-guide/authentication-flow/#overview","title":"Overview","text":"1. Challenge Generation The server generates a unique challenge for the user's Evrmore address 2. Signature Creation The user signs the challenge with their Evrmore wallet 3. Verification The server verifies the signature against the challenge 4. Token Issuance Upon successful verification, a JWT token is issued 5. Authentication The token is used for subsequent API requests"},{"location":"user-guide/authentication-flow/#step-1-challenge-generation","title":"Step 1: Challenge Generation","text":"<p>When a user attempts to authenticate, the server generates a unique challenge for their Evrmore address.</p> <pre><code># Server-side code\nfrom evrmore_authentication import EvrmoreAuth\n\nauth = EvrmoreAuth()\nchallenge = auth.generate_challenge(\"EXaMPLeEvRMoReAddResS\")\n</code></pre> <p>What happens behind the scenes:</p> <ol> <li>The system creates a unique challenge text, typically a random string with a timestamp</li> <li>The challenge is stored in the database with:</li> <li>The user's Evrmore address</li> <li>Creation timestamp</li> <li>Expiration timestamp (default: 15 minutes)</li> <li>A <code>user_challenges</code> record is created to track challenge ownership</li> <li>Event hooks (if defined) are triggered for challenge generation</li> </ol> <p>API Endpoint:</p> <pre><code>POST /challenge\n{\n  \"evrmore_address\": \"EXaMPLeEvRMoReAddResS\"\n}\n</code></pre> <p>The response includes the challenge text:</p> <pre><code>{\n  \"challenge\": \"Sign this message to authenticate: a8f7e9d1c2b3a4f5e6d7c8b9a1f2e3d4\",\n  \"expires_at\": \"2023-03-14T15:30:45Z\"\n}\n</code></pre>"},{"location":"user-guide/authentication-flow/#step-2-signature-creation","title":"Step 2: Signature Creation","text":"<p>The user signs the challenge with their Evrmore wallet. This is typically done client-side using wallet software or an extension.</p> <p>Example using evrmore-cli:</p> <pre><code>evrmore-cli signmessage \"EXaMPLeEvRMoReAddResS\" \"Sign this message to authenticate: a8f7e9d1c2b3a4f5e6d7c8b9a1f2e3d4\"\n</code></pre> <p>The output is a base64-encoded signature:</p> <pre><code>H9LJFkR+a0MFm1jSvmoBZ1wQobuSGPQ2C1TW/m9FVwnQJNjyZLX3ZzOOHI01jEL59YtJFXBH9PnwH...\n</code></pre>"},{"location":"user-guide/authentication-flow/#step-3-verification","title":"Step 3: Verification","text":"<p>The server verifies the signature against the challenge and the Evrmore address.</p> <pre><code># Server-side code\nsession = auth.authenticate(\n    evrmore_address=\"EXaMPLeEvRMoReAddResS\",\n    challenge=challenge,\n    signature=\"H9LJFkR+a0MFm1jSvmoBZ1wQobuSGPQ2C1TW/m9FVwnQJNjyZLX3ZzOOHI01jEL59YtJFXBH9PnwH...\"\n)\n</code></pre> <p>What happens behind the scenes:</p> <ol> <li>The system retrieves the challenge from the database and ensures it:</li> <li>Exists</li> <li>Belongs to the specified Evrmore address</li> <li>Hasn't expired</li> <li>Hasn't been used before</li> <li>The signature is verified cryptographically against the challenge and address</li> <li>The challenge is marked as used to prevent replay attacks</li> <li>Event hooks (if defined) are triggered for successful authentication</li> <li>If a user doesn't exist in the database, they are created automatically</li> </ol> <p>API Endpoint:</p> <pre><code>POST /authenticate\n{\n  \"evrmore_address\": \"EXaMPLeEvRMoReAddResS\",\n  \"challenge\": \"Sign this message to authenticate: a8f7e9d1c2b3a4f5e6d7c8b9a1f2e3d4\",\n  \"signature\": \"H9LJFkR+a0MFm1jSvmoBZ1wQobuSGPQ2C1TW/m9FVwnQJNjyZLX3ZzOOHI01jEL59YtJFXBH9PnwH...\"\n}\n</code></pre>"},{"location":"user-guide/authentication-flow/#step-4-token-issuance","title":"Step 4: Token Issuance","text":"<p>Upon successful verification, a JWT (JSON Web Token) is generated and issued to the user.</p> <pre><code># The authenticate method returns a session with a token\ntoken = session.token\n</code></pre> <p>What happens behind the scenes:</p> <ol> <li>A new session is created in the database with:</li> <li>User ID</li> <li>JWT token</li> <li>Creation timestamp</li> <li>Expiration timestamp (default: 30 minutes)</li> <li>The JWT is signed using the configured secret key and algorithm</li> <li>The token contains claims including:</li> <li>User ID</li> <li>Evrmore address</li> <li>Expiration time</li> <li>Issuance time</li> </ol> <p>API Response:</p> <pre><code>{\n  \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiZXZybW9yZV9hZGRyZXNzIjoiRVhhTVBMZUV2Uk1vUmVBZGRSZXNTIiwiZXhwIjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\",\n  \"expires_at\": \"2023-03-14T16:00:45Z\",\n  \"user\": {\n    \"id\": \"123e4567-e89b-12d3-a456-426614174000\",\n    \"evrmore_address\": \"EXaMPLeEvRMoReAddResS\"\n  }\n}\n</code></pre>"},{"location":"user-guide/authentication-flow/#step-5-authentication","title":"Step 5: Authentication","text":"<p>The JWT token is used for subsequent API requests to authenticate the user.</p> <pre><code># Client-side code for making authenticated requests\nimport requests\n\nheaders = {\n    \"Authorization\": f\"Bearer {token}\"\n}\n\nresponse = requests.get(\"https://api.example.com/protected-resource\", headers=headers)\n</code></pre> <p>What happens behind the scenes:</p> <ol> <li>The server extracts the token from the Authorization header</li> <li>The token is verified to ensure:</li> <li>It's properly signed</li> <li>It hasn't expired</li> <li>It hasn't been revoked</li> <li>The user information is extracted from the token</li> <li>The request proceeds with the authenticated user context</li> </ol> <p>API Endpoint for Token Validation:</p> <pre><code>GET /validate\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\n</code></pre> <p>Response:</p> <pre><code>{\n  \"valid\": true,\n  \"user\": {\n    \"id\": \"123e4567-e89b-12d3-a456-426614174000\",\n    \"evrmore_address\": \"EXaMPLeEvRMoReAddResS\"\n  }\n}\n</code></pre>"},{"location":"user-guide/authentication-flow/#logout-process","title":"Logout Process","text":"<p>To invalidate a token (logout):</p> <pre><code># Server-side code\nauth.invalidate_token(token)\n</code></pre> <p>What happens behind the scenes:</p> <ol> <li>The session associated with the token is marked as inactive</li> <li>The token can no longer be used for authentication</li> <li>Event hooks (if defined) are triggered for logout</li> </ol> <p>API Endpoint:</p> <pre><code>POST /logout\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\n</code></pre>"},{"location":"user-guide/authentication-flow/#security-considerations","title":"Security Considerations","text":"<p>The Evrmore Authentication flow offers several security benefits:</p> <ol> <li> <p>No Password Storage: The system never stores user passwords, eliminating password database theft risks.</p> </li> <li> <p>Challenge-Response Mechanism: Each authentication requires a new challenge, preventing replay attacks.</p> </li> <li> <p>Cryptographic Verification: Uses blockchain-grade cryptography to verify signatures.</p> </li> <li> <p>Short-lived Challenges: Challenges expire quickly (default: 15 minutes) to limit attack windows.</p> </li> <li> <p>Single-Use Challenges: Each challenge can only be used once, preventing replay attacks.</p> </li> <li> <p>JWT Best Practices: Implements security best practices for JWT handling.</p> </li> <li> <p>Database Integrity: Challenges and sessions are tracked in the database to prevent misuse.</p> </li> </ol> <p>For additional security, consider implementing:</p> <ul> <li>Rate limiting for challenge generation</li> <li>IP-based restrictions</li> <li>Additional user verification methods</li> <li>Hardware wallet support </li> </ul>"},{"location":"user-guide/basic-integration/","title":"Basic Integration","text":"<p>This guide demonstrates how to integrate Evrmore Authentication into your application using various methods, from direct API calls to framework integrations.</p>"},{"location":"user-guide/basic-integration/#installation","title":"Installation","text":"<p>Install the package using pip:</p> <pre><code>pip3 install evrmore-authentication\n</code></pre>"},{"location":"user-guide/basic-integration/#configuration","title":"Configuration","text":"<p>Create a <code>.env</code> file in your project root:</p> <pre><code># SQLite configuration\nSQLITE_DB_PATH=./data/evrmore_auth.db\n\n# JWT configuration\nJWT_SECRET=your-secure-secret-key\nJWT_ALGORITHM=HS256\nJWT_ACCESS_TOKEN_EXPIRE_MINUTES=30\n\n# Challenge configuration\nCHALLENGE_EXPIRE_MINUTES=10\n\n# Debug mode\nEVRMORE_AUTH_DEBUG=false\n\n# Logging\nLOG_LEVEL=INFO\n</code></pre>"},{"location":"user-guide/basic-integration/#direct-integration","title":"Direct Integration","text":"<p>You can use the <code>EvrmoreAuth</code> class directly in your Python application:</p> <pre><code>from evrmore_authentication import EvrmoreAuth\n\n# Initialize the authentication system\nauth = EvrmoreAuth()\n\n# Generate a challenge for a user's Evrmore address\nchallenge = auth.generate_challenge(\"EXaMPLeEvRMoReAddResS\")\n\n# Verify the signature provided by the user\nsession = auth.authenticate(\n    evrmore_address=\"EXaMPLeEvRMoReAddResS\",\n    challenge=challenge,\n    signature=\"signed_challenge_from_wallet\"\n)\n\n# Use the token for authentication\ntoken = session.token\n\n# Validate a token\ntoken_data = auth.validate_token(token)\n\n# Get user from token\nuser = auth.get_user_by_token(token)\n\n# Invalidate a token (logout)\nauth.invalidate_token(token)\n</code></pre>"},{"location":"user-guide/basic-integration/#api-server-integration","title":"API Server Integration","text":"<p>The package includes a ready-to-use FastAPI server with the following endpoints:</p> Endpoint Method Description <code>/challenge</code> POST Generate a challenge for a user <code>/authenticate</code> POST Authenticate with a signed challenge <code>/validate</code> GET Validate a JWT token <code>/me</code> GET Get authenticated user information <code>/logout</code> POST Invalidate a JWT token (logout)"},{"location":"user-guide/basic-integration/#running-the-api-server","title":"Running the API Server","text":"<pre><code>python3 -m scripts.run_api_server --host 0.0.0.0 --port 8000\n</code></pre>"},{"location":"user-guide/basic-integration/#api-client-example","title":"API Client Example","text":"<pre><code>import requests\n\n# Generate a challenge\nresponse = requests.post(\n    \"http://localhost:8000/challenge\",\n    json={\"evrmore_address\": \"EXaMPLeEvRMoReAddResS\"}\n)\nchallenge_data = response.json()\nchallenge = challenge_data[\"challenge\"]\n\n# User signs the challenge with their wallet...\nsignature = \"signature_from_wallet\"\n\n# Authenticate with the signed challenge\nresponse = requests.post(\n    \"http://localhost:8000/authenticate\",\n    json={\n        \"evrmore_address\": \"EXaMPLeEvRMoReAddResS\",\n        \"challenge\": challenge,\n        \"signature\": signature\n    }\n)\nauth_data = response.json()\ntoken = auth_data[\"token\"]\n\n# Use the token for authenticated requests\nheaders = {\"Authorization\": f\"Bearer {token}\"}\nresponse = requests.get(\"http://localhost:8000/me\", headers=headers)\nuser_data = response.json()\n\n# Logout\nresponse = requests.post(\n    \"http://localhost:8000/logout\", \n    headers=headers\n)\n</code></pre>"},{"location":"user-guide/basic-integration/#fastapi-integration","title":"FastAPI Integration","text":"<p>To integrate with your own FastAPI application:</p> <pre><code>from fastapi import FastAPI, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom evrmore_authentication import EvrmoreAuth, AuthException\n\napp = FastAPI(title=\"My API with Evrmore Authentication\")\nauth = EvrmoreAuth()\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n# Helper to get current user from token\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    try:\n        user = auth.get_user_by_token(token)\n        return user\n    except AuthException as e:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=str(e),\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n# Challenge generation endpoint\n@app.post(\"/challenge\")\nasync def generate_challenge(data: dict):\n    evrmore_address = data.get(\"evrmore_address\")\n    if not evrmore_address:\n        raise HTTPException(status_code=400, detail=\"Evrmore address is required\")\n\n    try:\n        challenge = auth.generate_challenge(evrmore_address)\n        return {\"challenge\": challenge}\n    except AuthException as e:\n        raise HTTPException(status_code=400, detail=str(e))\n\n# Authentication endpoint\n@app.post(\"/authenticate\")\nasync def authenticate(data: dict):\n    evrmore_address = data.get(\"evrmore_address\")\n    challenge = data.get(\"challenge\")\n    signature = data.get(\"signature\")\n\n    if not all([evrmore_address, challenge, signature]):\n        raise HTTPException(status_code=400, detail=\"Missing required parameters\")\n\n    try:\n        session = auth.authenticate(\n            evrmore_address=evrmore_address,\n            challenge=challenge,\n            signature=signature\n        )\n        return {\n            \"token\": session.token,\n            \"expires_at\": session.expires_at.isoformat()\n        }\n    except AuthException as e:\n        raise HTTPException(status_code=401, detail=str(e))\n\n# Protected endpoint\n@app.get(\"/me\")\nasync def get_me(user = Depends(get_current_user)):\n    return {\n        \"id\": user.id,\n        \"evrmore_address\": user.evrmore_address,\n        \"username\": user.username\n    }\n\n# Logout endpoint\n@app.post(\"/logout\")\nasync def logout(token: str = Depends(oauth2_scheme)):\n    try:\n        auth.invalidate_token(token)\n        return {\"success\": True}\n    except AuthException as e:\n        raise HTTPException(status_code=400, detail=str(e))\n</code></pre>"},{"location":"user-guide/basic-integration/#flask-integration","title":"Flask Integration","text":"<p>To integrate with Flask:</p> <pre><code>from flask import Flask, request, jsonify\nfrom evrmore_authentication import EvrmoreAuth, AuthException\nimport functools\n\napp = Flask(__name__)\nauth = EvrmoreAuth()\n\n# Decorator for protected routes\ndef token_required(f):\n    @functools.wraps(f)\n    def decorated(*args, **kwargs):\n        token = None\n\n        # Extract token from Authorization header\n        auth_header = request.headers.get('Authorization')\n        if auth_header and auth_header.startswith('Bearer '):\n            token = auth_header.split(' ')[1]\n\n        if not token:\n            return jsonify({'error': 'Token is missing'}), 401\n\n        try:\n            # Validate token and get user\n            user = auth.get_user_by_token(token)\n            return f(user, *args, **kwargs)\n        except AuthException as e:\n            return jsonify({'error': str(e)}), 401\n\n    return decorated\n\n@app.route('/challenge', methods=['POST'])\ndef generate_challenge():\n    data = request.get_json()\n    evrmore_address = data.get('evrmore_address')\n\n    if not evrmore_address:\n        return jsonify({'error': 'Evrmore address is required'}), 400\n\n    try:\n        challenge = auth.generate_challenge(evrmore_address)\n        return jsonify({'challenge': challenge})\n    except AuthException as e:\n        return jsonify({'error': str(e)}), 400\n\n@app.route('/authenticate', methods=['POST'])\ndef authenticate():\n    data = request.get_json()\n    evrmore_address = data.get('evrmore_address')\n    challenge = data.get('challenge')\n    signature = data.get('signature')\n\n    if not all([evrmore_address, challenge, signature]):\n        return jsonify({'error': 'Missing required parameters'}), 400\n\n    try:\n        session = auth.authenticate(\n            evrmore_address=evrmore_address,\n            challenge=challenge,\n            signature=signature\n        )\n        return jsonify({\n            'token': session.token,\n            'expires_at': session.expires_at.isoformat()\n        })\n    except AuthException as e:\n        return jsonify({'error': str(e)}), 401\n\n@app.route('/me', methods=['GET'])\n@token_required\ndef get_me(user):\n    return jsonify({\n        'id': user.id,\n        'evrmore_address': user.evrmore_address,\n        'username': user.username\n    })\n\n@app.route('/logout', methods=['POST'])\n@token_required\ndef logout(user):\n    token = request.headers.get('Authorization').split(' ')[1]\n    try:\n        auth.invalidate_token(token)\n        return jsonify({'success': True})\n    except AuthException as e:\n        return jsonify({'error': str(e)}), 400\n\nif __name__ == '__main__':\n    app.run(debug=True)\n</code></pre>"},{"location":"user-guide/basic-integration/#django-integration","title":"Django Integration","text":"<p>Create a Django authentication backend:</p> <pre><code># myapp/auth_backend.py\nfrom django.contrib.auth.backends import BaseBackend\nfrom django.contrib.auth.models import User\nfrom evrmore_authentication import EvrmoreAuth\n\nclass EvrmoreAuthBackend(BaseBackend):\n    def authenticate(self, request, token=None):\n        if not token:\n            return None\n\n        auth = EvrmoreAuth()\n        try:\n            evrmore_user = auth.get_user_by_token(token)\n            # Get or create Django user\n            user, created = User.objects.get_or_create(\n                username=evrmore_user.evrmore_address,\n                defaults={\n                    'email': evrmore_user.email or '',\n                    'first_name': evrmore_user.username or ''\n                }\n            )\n            return user\n        except Exception:\n            return None\n\n    def get_user(self, user_id):\n        try:\n            return User.objects.get(pk=user_id)\n        except User.DoesNotExist:\n            return None\n</code></pre> <p>Add API views:</p> <pre><code># myapp/views.py\nfrom django.http import JsonResponse\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.views.decorators.http import require_http_methods\nimport json\nfrom evrmore_authentication import EvrmoreAuth\nfrom django.contrib.auth import authenticate, login, logout\n\nauth = EvrmoreAuth()\n\n@csrf_exempt\n@require_http_methods([\"POST\"])\ndef challenge(request):\n    try:\n        data = json.loads(request.body)\n        evrmore_address = data.get('evrmore_address')\n\n        if not evrmore_address:\n            return JsonResponse({'error': 'Evrmore address is required'}, status=400)\n\n        challenge = auth.generate_challenge(evrmore_address)\n        return JsonResponse({'challenge': challenge})\n    except Exception as e:\n        return JsonResponse({'error': str(e)}, status=400)\n\n@csrf_exempt\n@require_http_methods([\"POST\"])\ndef authenticate_user(request):\n    try:\n        data = json.loads(request.body)\n        evrmore_address = data.get('evrmore_address')\n        challenge = data.get('challenge')\n        signature = data.get('signature')\n\n        if not all([evrmore_address, challenge, signature]):\n            return JsonResponse({'error': 'Missing required parameters'}, status=400)\n\n        session = auth.authenticate(\n            evrmore_address=evrmore_address,\n            challenge=challenge,\n            signature=signature\n        )\n\n        # Authenticate with Django\n        user = authenticate(request, token=session.token)\n        if user:\n            login(request, user)\n\n        return JsonResponse({\n            'token': session.token,\n            'expires_at': session.expires_at.isoformat()\n        })\n    except Exception as e:\n        return JsonResponse({'error': str(e)}, status=401)\n\ndef user_info(request):\n    if not request.user.is_authenticated:\n        return JsonResponse({'error': 'Not authenticated'}, status=401)\n\n    return JsonResponse({\n        'id': request.user.id,\n        'username': request.user.username,\n        'email': request.user.email\n    })\n\n@csrf_exempt\n@require_http_methods([\"POST\"])\ndef logout_user(request):\n    # Get token from header\n    auth_header = request.META.get('HTTP_AUTHORIZATION', '')\n    if auth_header.startswith('Bearer '):\n        token = auth_header.split(' ')[1]\n        try:\n            auth.invalidate_token(token)\n            logout(request)\n            return JsonResponse({'success': True})\n        except Exception as e:\n            return JsonResponse({'error': str(e)}, status=400)\n\n    return JsonResponse({'error': 'Invalid Authorization header'}, status=400)\n</code></pre> <p>Configure Django settings:</p> <pre><code># settings.py\nAUTHENTICATION_BACKENDS = [\n    'myapp.auth_backend.EvrmoreAuthBackend',\n    'django.contrib.auth.backends.ModelBackend',  # Default backend\n]\n</code></pre>"},{"location":"user-guide/basic-integration/#next-steps","title":"Next Steps","text":"<p>Once you've integrated basic authentication, consider:</p> <ol> <li>Implementing the OAuth 2.0 flow for third-party integrations</li> <li>Adding event hooks for custom behavior</li> <li>Implementing custom user management</li> <li>Exploring advanced features for enhanced security </li> </ol>"},{"location":"user-guide/debugging/","title":"Debugging Guide &amp; Advanced Features","text":"<p>This guide explains how to use the advanced features and debugging capabilities of Evrmore Authentication.</p>"},{"location":"user-guide/debugging/#debugging-mode","title":"Debugging Mode","text":"<p>Evrmore Authentication includes a detailed debug mode that can help you troubleshoot issues:</p>"},{"location":"user-guide/debugging/#enabling-debug-mode","title":"Enabling Debug Mode","text":"<p>You can enable debug mode in several ways:</p> <ol> <li> <p>Environment Variable:    <pre><code>export EVRMORE_AUTH_DEBUG=true\n</code></pre></p> </li> <li> <p>Direct Initialization:    <pre><code>from evrmore_authentication import EvrmoreAuth\nauth = EvrmoreAuth(debug=True)\n</code></pre></p> </li> </ol> <p>When debug mode is enabled, detailed logging will show: - Challenge generation steps - Challenge ownership details - Signature verification attempts - Database operations - Hook execution details</p>"},{"location":"user-guide/debugging/#utility-scripts","title":"Utility Scripts","text":"<p>Evrmore Authentication comes with several utility scripts to help you manage the system:</p>"},{"location":"user-guide/debugging/#database-management","title":"Database Management","text":"<p>The <code>db_manage.py</code> script provides tools to manage your database:</p> <pre><code># Initialize the database\n./scripts/db_manage.py init\n\n# Show database information\n./scripts/db_manage.py info\n\n# List users\n./scripts/db_manage.py list-users\n\n# List challenges\n./scripts/db_manage.py list-challenges\n\n# List sessions\n./scripts/db_manage.py list-sessions\n\n# Clean up expired records\n./scripts/db_manage.py cleanup\n\n# Check database integrity\n./scripts/db_manage.py check-integrity\n</code></pre>"},{"location":"user-guide/debugging/#managing-challenges","title":"Managing Challenges","text":"<p>You can view, create, and reassign challenges:</p> <pre><code># List challenges for a specific address\n./scripts/db_manage.py list-challenges -a \"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\"\n\n# Create a challenge for an address\n./scripts/db_manage.py create-challenge \"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\"\n\n# Reassign a challenge to a different address\n./scripts/db_manage.py reassign \"Sign this message...\" \"ENewAddressHere\"\n</code></pre>"},{"location":"user-guide/debugging/#signature-verification","title":"Signature Verification","text":"<p>The <code>verify_signature.py</code> script allows you to verify signatures without database interaction:</p> <pre><code># Verify a signature\n./scripts/verify_signature.py verify \"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\" \"message to verify\" \"signature\"\n\n# Generate a challenge format\n./scripts/verify_signature.py challenge \"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\"\n</code></pre>"},{"location":"user-guide/debugging/#event-hooks","title":"Event Hooks","text":"<p>Evrmore Authentication supports event hooks that let you customize the authentication flow:</p> <pre><code>from evrmore_authentication import EvrmoreAuth\n\nauth = EvrmoreAuth()\n\n# Add a hook to run before challenge generation\ndef pre_challenge_hook(address, expire_minutes):\n    print(f\"Generating challenge for {address}\")\n    return {\"custom_data\": \"value\"}\n\nauth.add_hook('pre_challenge', pre_challenge_hook)\n\n# Available hook points:\n# - pre_challenge: Before generating a challenge\n# - post_challenge: After generating a challenge\n# - pre_auth: Before authenticating a user\n# - post_auth: After successful authentication\n# - pre_verify: Before verifying a signature\n# - post_verify: After verifying a signature\n</code></pre>"},{"location":"user-guide/debugging/#advanced-authentication-options","title":"Advanced Authentication Options","text":""},{"location":"user-guide/debugging/#skip-ownership-checks","title":"Skip Ownership Checks","text":"<p>When authenticating, you can skip the challenge ownership check:</p> <pre><code>session = auth.authenticate(\n    evrmore_address=\"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\",\n    challenge=challenge_text,\n    signature=signature,\n    skip_ownership_check=True  # Skip the ownership check\n)\n</code></pre> <p>This is useful when: - You're migrating users from another system - You want to manually verify challenges - You're using a custom challenge format</p>"},{"location":"user-guide/debugging/#direct-signature-verification","title":"Direct Signature Verification","text":"<p>You can verify signatures directly without challenge management:</p> <pre><code># Just verify the signature\nis_valid = auth.verify_signature_only(\n    address=\"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\",\n    message=\"message to verify\",\n    signature=\"signature\"\n)\n</code></pre>"},{"location":"user-guide/debugging/#challenge-management","title":"Challenge Management","text":"<p>You can manually manage challenges using these methods:</p> <pre><code># Get information about a challenge\nchallenge_info = auth.get_challenge_details(challenge_text)\n\n# Reassign a challenge to a different user\nauth.reassign_challenge(\n    challenge_text=\"challenge_text\", \n    new_address=\"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\"\n)\n\n# Create a manual challenge\nchallenge = auth.create_manual_challenge(\n    evrmore_address=\"EY8NRvv83BYMXSDf5DJYCmZQAhaMzZLWgW\",\n    challenge_text=\"custom challenge text\"  # Optional\n)\n</code></pre>"},{"location":"user-guide/debugging/#database-maintenance","title":"Database Maintenance","text":""},{"location":"user-guide/debugging/#clean-up-expired-records","title":"Clean Up Expired Records","text":"<p>You can clean up expired records programmatically:</p> <pre><code># Clean up expired challenges\nexpired_challenges = auth.cleanup_expired_challenges()\nprint(f\"Removed {expired_challenges} expired challenges\")\n\n# Clean up expired sessions\nexpired_sessions = auth.cleanup_expired_sessions()\nprint(f\"Removed {expired_sessions} expired sessions\")\n</code></pre>"},{"location":"user-guide/debugging/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"user-guide/debugging/#challenge-ownership-errors","title":"Challenge Ownership Errors","text":"<p>If you encounter \"Challenge does not belong to this user\" errors:</p> <ol> <li>Check if the challenge was generated for a different address:</li> </ol> <pre><code>./scripts/db_manage.py list-challenges -a \"correct-address\"\n</code></pre> <ol> <li>Reassign the challenge to the correct user:</li> </ol> <pre><code>./scripts/db_manage.py reassign \"challenge text\" \"correct-address\"\n</code></pre> <p>Or programmatically:</p> <pre><code>auth.reassign_challenge(challenge_text, new_address=\"correct-address\")\n</code></pre>"},{"location":"user-guide/debugging/#signature-verification-failures","title":"Signature Verification Failures","text":"<p>If signature verification fails:</p> <ol> <li>Verify the signature format using the verification tool:</li> </ol> <pre><code>./scripts/verify_signature.py verify \"address\" \"message\" \"signature\"\n</code></pre> <ol> <li>Check if your wallet is using a different message format. Try these options in your code:</li> </ol> <pre><code># Option 1: Skip ownership checks\nsession = auth.authenticate(\n    evrmore_address=address,\n    challenge=challenge,\n    signature=signature,\n    skip_ownership_check=True\n)\n\n# Option 2: Add a custom verification hook\ndef custom_verify_hook(address, message, signature):\n    # Custom verification logic\n    return True  # or False\n\nauth.add_hook('pre_verify', custom_verify_hook)\n</code></pre>"},{"location":"user-guide/oauth-implementation/","title":"OAuth 2.0 Implementation","text":"<p>Evrmore Authentication includes a comprehensive OAuth 2.0 server implementation, allowing your application to function as an identity provider for third-party applications.</p>"},{"location":"user-guide/oauth-implementation/#overview","title":"Overview","text":"<p>The OAuth 2.0 implementation supports:</p> <ul> <li>Standard Authorization Code flow</li> <li>Access and refresh token management</li> <li>Scoped permissions</li> <li>User info endpoint</li> <li>Token revocation</li> <li>Client registration and management</li> </ul>"},{"location":"user-guide/oauth-implementation/#setup-and-configuration","title":"Setup and Configuration","text":""},{"location":"user-guide/oauth-implementation/#database-configuration","title":"Database Configuration","text":"<p>The OAuth system requires a properly configured database. By default, it uses SQLite located at <code>./evrmore_authentication/data/evrmore_auth.db</code>.</p> <ol> <li>Set the database path in your <code>.env</code> file:</li> </ol> <pre><code>SQLITE_DB_PATH=./evrmore_authentication/data/evrmore_auth.db\n</code></pre> <ol> <li>Initialize the database:</li> </ol> <pre><code>python3 -m scripts.db_manage init\n</code></pre> <p>This command creates the necessary tables for the OAuth system, including: - <code>oauth_clients</code> - Stores registered OAuth client applications - <code>oauth_authorization_codes</code> - Stores temporary authorization codes - <code>oauth_tokens</code> - Stores access and refresh tokens</p>"},{"location":"user-guide/oauth-implementation/#running-the-authentication-server","title":"Running the Authentication Server","text":"<p>Start the authentication server with:</p> <pre><code>python3 -m scripts.run_api_server --port 8001\n</code></pre> <p>The server provides all the OAuth endpoints needed for the authorization flow.</p>"},{"location":"user-guide/oauth-implementation/#client-registration","title":"Client Registration","text":"<p>Before using OAuth, you must register a client application. The system provides a dedicated script for this purpose.</p>"},{"location":"user-guide/oauth-implementation/#using-the-client-registration-script","title":"Using the Client Registration Script","text":"<p>The <code>scripts/register_oauth_client.py</code> script simplifies OAuth client registration:</p> <pre><code>python3 scripts/register_oauth_client.py register \\\n    --name \"Your Application Name\" \\\n    --redirects \"http://your-app.com/callback\" \\\n    --uri \"http://your-app.com\" \\\n    --scopes \"profile,email\" \\\n    --response-types \"code\"\n</code></pre> <p>Parameters: - <code>--name</code>: Your application's name (displayed to users) - <code>--redirects</code>: Comma-separated list of allowed redirect URIs - <code>--uri</code>: Your application's main URI (optional) - <code>--scopes</code>: Comma-separated list of scopes your app needs - <code>--response-types</code>: Response types your app supports (usually \"code\")</p>"},{"location":"user-guide/oauth-implementation/#managing-clients","title":"Managing Clients","text":"<p>You can list registered clients:</p> <pre><code>python3 scripts/register_oauth_client.py list\n</code></pre> <p>Or delete a client:</p> <pre><code>python3 scripts/register_oauth_client.py delete --client-id YOUR_CLIENT_ID\n</code></pre>"},{"location":"user-guide/oauth-implementation/#storing-client-credentials","title":"Storing Client Credentials","text":"<p>The script will output client credentials that should be stored securely. For example:</p> <pre><code>Successfully registered new OAuth client:\n  ID:             92fae2b2-f231-43a4-945c-8c9f1f737627\n  Client ID:      d5fdcc0c-7a88-4cfc-a1ff-6af04b92e9b0\n  Client Secret:  XBBMQM9kppmbCyT5opG5FCZ0g89osYeKkrlNrmbIfKk\n  Name:           FastAPI OAuth Example\n  Redirect URIs:  http://localhost:8000/callback\n  Scopes:         profile\n  Response Types: code\n</code></pre> <p>We recommend creating a dedicated <code>.env.oauth</code> file to store these credentials:</p> <pre><code># OAuth Client Credentials\nOAUTH_CLIENT_ID=d5fdcc0c-7a88-4cfc-a1ff-6af04b92e9b0\nOAUTH_CLIENT_SECRET=XBBMQM9kppmbCyT5opG5FCZ0g89osYeKkrlNrmbIfKk\nOAUTH_REDIRECT_URI=http://localhost:8000/callback\n\n# Authorization Server Settings\nAUTH_SERVER_URL=http://localhost:8001\n</code></pre>"},{"location":"user-guide/oauth-implementation/#oauth-20-flow-implementation","title":"OAuth 2.0 Flow Implementation","text":"<p>The OAuth 2.0 implementation follows the standard Authorization Code flow:</p>"},{"location":"user-guide/oauth-implementation/#step-1-redirect-to-authorization-endpoint","title":"Step 1: Redirect to Authorization Endpoint","text":"<p>Redirect the user to the authorization endpoint:</p> <pre><code>import uuid\nfrom urllib.parse import urlencode\n\n# Generate state parameter to prevent CSRF\nstate = str(uuid.uuid4())\nsession['oauth_state'] = state\n\n# Build the authorization URL\nparams = {\n    \"client_id\": CLIENT_ID,\n    \"redirect_uri\": REDIRECT_URI,\n    \"response_type\": \"code\",\n    \"scope\": \"profile email\",\n    \"state\": state\n}\n\nauth_url = f\"{AUTH_SERVER}/oauth/authorize?{urlencode(params)}\"\nreturn redirect(auth_url)\n</code></pre>"},{"location":"user-guide/oauth-implementation/#step-2-user-authentication","title":"Step 2: User Authentication","text":"<p>The user will be presented with an authentication page where they: 1. Enter their Evrmore wallet address 2. Receive a challenge to sign 3. Sign the challenge with their wallet 4. Submit the signature for verification</p>"},{"location":"user-guide/oauth-implementation/#step-3-handle-the-callback","title":"Step 3: Handle the Callback","text":"<p>When authentication succeeds, the user is redirected to your redirect URI with a code:</p> <pre><code>def oauth_callback(code, state):\n    # Verify state parameter\n    if state != session.get('oauth_state'):\n        return \"Invalid state parameter\", 400\n\n    # Exchange code for tokens\n    token_response = requests.post(\n        f\"{AUTH_SERVER}/oauth/token\",\n        data={\n            \"grant_type\": \"authorization_code\",\n            \"code\": code,\n            \"redirect_uri\": REDIRECT_URI,\n            \"client_id\": CLIENT_ID,\n            \"client_secret\": CLIENT_SECRET\n        },\n        headers={\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n        }\n    )\n\n    token_data = token_response.json()\n\n    # Store tokens securely\n    session['access_token'] = token_data[\"access_token\"]\n    session['refresh_token'] = token_data[\"refresh_token\"]\n\n    return redirect('/profile')\n</code></pre>"},{"location":"user-guide/oauth-implementation/#step-4-access-protected-resources","title":"Step 4: Access Protected Resources","text":"<p>Use the access token to fetch user info or access protected resources:</p> <pre><code>def get_user_profile():\n    access_token = session.get('access_token')\n\n    response = requests.get(\n        f\"{AUTH_SERVER}/oauth/userinfo\",\n        headers={\n            \"Authorization\": f\"Bearer {access_token}\"\n        }\n    )\n\n    user_data = response.json()\n    return render_template('profile.html', user=user_data)\n</code></pre>"},{"location":"user-guide/oauth-implementation/#step-5-refresh-tokens","title":"Step 5: Refresh Tokens","text":"<p>When the access token expires, use the refresh token to get a new one:</p> <pre><code>def refresh_access_token():\n    refresh_token = session.get('refresh_token')\n\n    response = requests.post(\n        f\"{AUTH_SERVER}/oauth/token\",\n        data={\n            \"grant_type\": \"refresh_token\",\n            \"refresh_token\": refresh_token,\n            \"client_id\": CLIENT_ID,\n            \"client_secret\": CLIENT_SECRET\n        },\n        headers={\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n        }\n    )\n\n    token_data = response.json()\n\n    # Update tokens\n    session['access_token'] = token_data[\"access_token\"]\n    session['refresh_token'] = token_data[\"refresh_token\"]\n\n    return token_data\n</code></pre>"},{"location":"user-guide/oauth-implementation/#step-6-logout-token-revocation","title":"Step 6: Logout (Token Revocation)","text":"<p>When the user logs out, revoke their tokens:</p> <pre><code>def logout():\n    access_token = session.get('access_token')\n\n    requests.post(\n        f\"{AUTH_SERVER}/oauth/revoke\",\n        json={\n            \"token\": access_token,\n            \"client_id\": CLIENT_ID,\n            \"client_secret\": CLIENT_SECRET\n        }\n    )\n\n    # Clear session\n    session.clear()\n    return redirect('/')\n</code></pre>"},{"location":"user-guide/oauth-implementation/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Use HTTPS in production environments</li> <li>Set secure cookie attributes:</li> <li><code>httpOnly</code> - Prevents JavaScript access</li> <li><code>secure</code> - Ensures cookies are sent only over HTTPS</li> <li> <p><code>sameSite=lax</code> - Protects against CSRF</p> </li> <li> <p>Validate state parameter to prevent CSRF attacks</p> </li> <li>Store client secrets securely and never expose them client-side</li> <li>Implement proper error handling for authentication failures</li> <li>Use refresh tokens for longer sessions rather than extending access token lifetimes</li> <li>Revoke tokens when users log out</li> </ol> <p>For full example implementations, see the FastAPI OAuth Example in the Examples section. </p>"},{"location":"user-guide/troubleshooting/","title":"Troubleshooting Guide","text":"<p>This guide provides tools and techniques for troubleshooting the Evrmore Authentication system, with a focus on the OAuth 2.0 implementation and common issues users might encounter.</p>"},{"location":"user-guide/troubleshooting/#debugging-tools","title":"Debugging Tools","text":"<p>The Evrmore Authentication system includes several debugging tools that can help diagnose issues.</p>"},{"location":"user-guide/troubleshooting/#database-monitoring-tools","title":"Database Monitoring Tools","text":""},{"location":"user-guide/troubleshooting/#check_dbpy","title":"<code>check_db.py</code>","text":"<p>This script provides a simple way to check the contents of the SQLite database:</p> <pre><code>python3 check_db.py\n</code></pre> <p>It displays a summary of database contents including: - Users - Sessions - Challenges - Authorization Codes - OAuth Clients</p>"},{"location":"user-guide/troubleshooting/#check_auth_codespy","title":"<code>check_auth_codes.py</code>","text":"<p>This script provides real-time monitoring of OAuth authorization codes in the database:</p> <pre><code>python3 check_auth_codes.py\n</code></pre> <p>It shows detailed information about each authorization code, including: - Code value - Client ID - User ID - Redirect URI - Scope - Creation and expiration timestamps - Used status</p> <p>This tool is particularly useful for debugging the OAuth authorization code flow, as you can see the codes being created and used in real-time.</p>"},{"location":"user-guide/troubleshooting/#check_oauth_clientspy","title":"<code>check_oauth_clients.py</code>","text":"<p>This script checks for registered OAuth clients in the database:</p> <pre><code>python3 check_oauth_clients.py\n</code></pre> <p>It displays a list of all registered OAuth clients, including: - Client ID - Client Secret (partially masked) - Name - Redirect URIs - Scopes - Active status</p>"},{"location":"user-guide/troubleshooting/#log-monitoring","title":"Log Monitoring","text":""},{"location":"user-guide/troubleshooting/#monitor_logspy","title":"<code>monitor_logs.py</code>","text":"<p>This script provides real-time monitoring of the authentication server logs:</p> <pre><code>python3 monitor_logs.py\n</code></pre> <p>It tails the <code>auth_server.log</code> file and displays new log entries as they are added. This is useful for seeing detailed information about the authentication process, including debug messages and errors.</p>"},{"location":"user-guide/troubleshooting/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"user-guide/troubleshooting/#oauth-20-issues","title":"OAuth 2.0 Issues","text":""},{"location":"user-guide/troubleshooting/#invalid-client_id-error","title":"\"Invalid client_id\" Error","text":"<p>If you encounter an \"Invalid client_id\" error:</p> <ol> <li> <p>Verify that the client ID is registered in the database:    <pre><code>python3 scripts/register_oauth_client.py list\n</code></pre></p> </li> <li> <p>Ensure the database path is consistent between your server and client:    <pre><code>SQLITE_DB_PATH=./evrmore_authentication/data/evrmore_auth.db\n</code></pre></p> </li> <li> <p>Re-register the client if necessary:    <pre><code>python3 scripts/register_oauth_client.py register \\\n    --name \"Your App\" --redirects \"http://your-app.com/callback\"\n</code></pre></p> </li> </ol>"},{"location":"user-guide/troubleshooting/#missing-or-expired-oauth-session-error","title":"\"Missing or expired OAuth session\" Error","text":"<p>This error occurs when the OAuth session cookie is missing or invalid:</p> <ol> <li>Ensure cookies are properly stored and have appropriate security settings</li> <li>Check that the session duration is sufficient</li> <li>Verify the state parameter is properly managed</li> </ol>"},{"location":"user-guide/troubleshooting/#authorization-code-exchange-fails-422-error","title":"Authorization Code Exchange Fails (422 Error)","text":"<p>If token exchange fails with a 422 error:</p> <ol> <li> <p>Ensure the content type is correctly set for the token request:    <pre><code>headers={\"Content-Type\": \"application/x-www-form-urlencoded\"}\n</code></pre></p> </li> <li> <p>Verify that you're sending form data rather than JSON:    <pre><code># Correct:\nrequests.post(url, data={\"grant_type\": \"authorization_code\", ...})\n\n# Incorrect:\nrequests.post(url, json={\"grant_type\": \"authorization_code\", ...})\n</code></pre></p> </li> <li> <p>Check that all required parameters are included:</p> </li> <li><code>grant_type</code></li> <li><code>code</code></li> <li><code>redirect_uri</code></li> <li><code>client_id</code></li> <li><code>client_secret</code></li> </ol>"},{"location":"user-guide/troubleshooting/#authentication-issues","title":"Authentication Issues","text":""},{"location":"user-guide/troubleshooting/#failed-to-verify-signature-error","title":"\"Failed to verify signature\" Error","text":"<p>If signature verification fails:</p> <ol> <li>Ensure the user is signing the exact challenge text provided</li> <li>Check that the signature and Evrmore address match</li> <li> <p>Make sure you're using the correct verification order in any custom code:    <pre><code># Correct order:\nverify_message(address, message, signature)\n</code></pre></p> </li> <li> <p>Ensure the signature was created using the correct wallet</p> </li> </ol>"},{"location":"user-guide/troubleshooting/#challenge-expiration-issues","title":"Challenge Expiration Issues","text":"<p>Challenges are designed to expire after a set time (default: 15 minutes):</p> <ol> <li> <p>Check if the challenge has expired:    <pre><code>challenge_details = auth.get_challenge_details(challenge_text)\nprint(f\"Expires at: {challenge_details.expires_at}\")\n</code></pre></p> </li> <li> <p>Generate a new challenge if needed:    <pre><code>new_challenge = auth.generate_challenge(evrmore_address)\n</code></pre></p> </li> <li> <p>Adjust the expiration time if challenges expire too quickly:    <pre><code># Set longer expiration (30 minutes)\nchallenge = auth.generate_challenge(evrmore_address, expire_minutes=30)\n</code></pre></p> </li> </ol>"},{"location":"user-guide/troubleshooting/#database-issues","title":"Database Issues","text":""},{"location":"user-guide/troubleshooting/#missing-tables","title":"Missing Tables","text":"<p>If you see errors about missing tables, initialize the database: <pre><code>python3 -m scripts.db_manage init\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#database-path-mismatch","title":"Database Path Mismatch","text":"<p>Ensure your <code>.env</code> file has the correct path: <pre><code>SQLITE_DB_PATH=./evrmore_authentication/data/evrmore_auth.db\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#sqlite-permissions","title":"SQLite Permissions","text":"<p>If you get permission errors, check file permissions on the database file and directory: <pre><code># Check permissions\nls -la ./evrmore_authentication/data/\n\n# Fix permissions if needed\nchmod 644 ./evrmore_authentication/data/evrmore_auth.db\nchmod 755 ./evrmore_authentication/data/\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#server-issues","title":"Server Issues","text":""},{"location":"user-guide/troubleshooting/#server-wont-start","title":"Server Won't Start","text":"<p>Check that the port is not already in use: <pre><code># Check if port 8001 is in use\nlsof -i :8001\n\n# Kill the process using the port\npkill -f \"python3 -m scripts.run_api_server\"\n</code></pre></p>"},{"location":"user-guide/troubleshooting/#cors-errors","title":"CORS Errors","text":"<p>If you're getting CORS errors in the browser, check the CORS configuration in the API server:</p> <ol> <li>Ensure the client domain is allowed</li> <li>Use the <code>--allow-origins</code> flag when starting the server:    <pre><code>python3 -m scripts.run_api_server --port 8001 --allow-origins \"http://localhost:8000,https://your-app.com\"\n</code></pre></li> </ol>"},{"location":"user-guide/troubleshooting/#running-tests","title":"Running Tests","text":"<p>The test suite can help diagnose issues:</p> <pre><code># Run all tests\npython3 -m pytest\n\n# Run specific tests\npython3 -m pytest evrmore_authentication/tests/unit/test_auth.py\n\n# Run tests with verbose output\npython3 -m pytest -v\n</code></pre>"},{"location":"user-guide/troubleshooting/#debug-mode","title":"Debug Mode","text":"<p>Enable debug mode in your <code>.env</code> file to get more detailed logs: <pre><code>DEBUG_MODE=True\nLOG_LEVEL=DEBUG\n</code></pre></p> <p>This will provide verbose logging for all operations, making it easier to identify the source of issues.</p>"},{"location":"user-guide/troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you encounter persistent issues:</p> <ol> <li> <p>Check the GitHub Issues for similar problems and solutions.</p> </li> <li> <p>Contact support:</p> </li> <li>Email: dev@manticore.technology</li> <li>GitHub: https://github.com/manticoretechnologies </li> </ol>"}]}